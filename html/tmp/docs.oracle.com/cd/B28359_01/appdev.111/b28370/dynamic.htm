<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using Dynamic SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.1 Build 005" />
<meta name="dcterms.created" content="2009-08-27T3:21:51Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Language Reference" />
<meta name="dcterms.identifier" content="B28370-05" />
<meta name="dcterms.isVersionOf" content="LNPLS" />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="static.htm" title="Previous" type="text/html" />
<link rel="Next" href="subprograms.htm" title="Next" type="text/html" />
<link rel="alternate" href="../b28370.pdf" title="PDF version" type="application/pdf" />
<link rel="alternate" href="../B28370-05.epub" title="ePub version" type="application/epub+zip" />
<link rel="alternate" href="../B28370-05.mobi" title="Mobipocket version" type="application/x-mobipocket-ebook" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a>
<header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/89</span> <!-- End Header --><a id="CACDDACH"></a>
<h1 class="chapter"><span class="secnum">7</span> <a id="LNPLS011"></a> Using Dynamic SQL</h1>
<p><a id="sthref852"></a><a id="sthref853"></a><span class="bold">Dynamic SQL</span> is a programming methodology for generating and executing SQL statements at run time. It is useful when writing general-purpose and flexible programs like ad hoc query systems, when writing programs that must execute DDL statements, or when you do not know at compilation time the full text of a SQL statement or the number or data types of its input and output variables.</p>
<p>PL/SQL provides two ways to write dynamic SQL:</p>
<ul>
<li>
<p>Native dynamic SQL, a PL/SQL language (that is, native) feature for building and executing dynamic SQL statements</p>
</li>
<li>
<p><code>DBMS_SQL</code> package, an API for building, executing, and describing dynamic SQL statements</p>
</li>
</ul>
<p>Native dynamic SQL code is easier to read and write than equivalent code that uses the <code>DBMS_SQL</code> package, and runs noticeably faster (especially when it can be optimized by the compiler). However, to write native dynamic SQL code, you must know at compile time the number and data types of the input and output variables of the dynamic SQL statement. If you do not know this information at compile time, you must use the <code>DBMS_SQL</code> package.</p>
<p>When you need both the <code>DBMS_SQL</code> package and native dynamic SQL, you can switch between them, using the <a href="#BHCECGGF">DBMS_SQL.TO_REFCURSOR Function</a> and <a href="#BHCBJGEH">DBMS_SQL.TO_CURSOR_NUMBER Function</a>.</p>
<p>Topics:</p>
<ul>
<li>
<p><a href="#i12999">When You Need Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i13130">Using Native Dynamic SQL</a></p>
</li>
<li>
<p><a href="#BHCIBJBG">Using DBMS_SQL Package</a></p>
</li>
<li>
<p><a href="#CHDFCHHJ">Avoiding SQL Injection in PL/SQL</a></p>
</li>
</ul>
<a id="i12999"></a>
<div class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1"><a id="LNPLS01101"></a>When You Need Dynamic SQL</h2>
<p>In PL/SQL, you need dynamic SQL in order to execute the following:</p>
<ul>
<li>
<p>SQL whose text is unknown at compile time</p>
<p>For example, a <code>SELECT</code> statement that includes an identifier that is unknown at compile time (such as a table name) or a <code>WHERE</code> clause in which the number of subclauses is unknown at compile time.</p>
</li>
<li>
<p>SQL that is not supported as static SQL</p>
<p>That is, any SQL construct not included in <a href="static.htm#i7112">Description of Static SQL</a>.</p>
</li>
</ul>
<p>If you do not need dynamic SQL, use static SQL, which has the following advantages:</p>
<ul>
<li>
<p>Successful compilation verifies that static SQL statements reference valid database objects and that the necessary privileges are in place to access those objects.</p>
</li>
<li>
<p>Successful compilation creates schema object dependencies.</p>
<p>For information about schema object dependencies, see <a class="olink CNCPT1858" href="../../server.111/b28318/dependencies.htm#CNCPT1858"><span class="italic">Oracle Database Concepts</span></a>.</p>
</li>
</ul>
<p>For information about using static SQL statements with PL/SQL, see <a href="static.htm#BABGEDAE">Chapter 6, "Using Static SQL."</a></p>
</div>
<!-- class="sect1" -->
<a id="i13130"></a>
<div class="sect1">
<h2 class="sect1"><a id="LNPLS01102"></a>Using Native Dynamic SQL</h2>
<p><a id="sthref854"></a><a id="sthref855"></a>Native dynamic SQL processes most dynamic SQL statements by means of the <code>EXECUTE</code> <code>IMMEDIATE</code> statement.</p>
<p>If the dynamic SQL statement is a <code>SELECT</code> statement that returns multiple rows, native dynamic SQL gives you the following choices:</p>
<ul>
<li>
<p>Use the <code>EXECUTE</code> <code>IMMEDIATE</code> statement with the <code>BULK</code> <code>COLLECT</code> <code>INTO</code> clause.</p>
</li>
<li>
<p>Use the <code>OPEN-FOR</code>, <code>FETCH</code>, and <code>CLOSE</code> statements.</p>
</li>
</ul>
<p><a id="sthref856"></a>The SQL cursor attributes work the same way after native dynamic SQL <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and single-row <code>SELECT</code> statements as they do for their static SQL counterparts. For more information about SQL cursor attributes, see <a href="static.htm#i45288">Managing Cursors in PL/SQL</a>.</p>
<p>Topics:</p>
<ul>
<li>
<p><a href="#BHCEBBAI">Using the EXECUTE IMMEDIATE Statement</a></p>
</li>
<li>
<p><a href="#i13057">Using the OPEN-FOR, FETCH, and CLOSE Statements</a></p>
</li>
<li>
<p><a href="#BHCGEFCA">Repeating Placeholder Names in Dynamic SQL Statements</a></p>
</li>
</ul>
<a id="BHCEBBAI"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="LNPLS01115"></a>Using the EXECUTE IMMEDIATE Statement</h3>
<p><a id="sthref857"></a>The <code>EXECUTE</code> <code>IMMEDIATE</code> statement is the means by which native dynamic SQL processes most dynamic SQL statements.</p>
<p>If the dynamic SQL statement is <span class="bold">self-contained</span> (that is, if it has no placeholders for bind arguments and the only result that it can possibly return is an error), then the <code>EXECUTE</code> <code>IMMEDIATE</code> statement needs no clauses.</p>
<p>If the dynamic SQL statement includes placeholders for bind arguments, each placeholder must have a corresponding bind argument in the appropriate clause of the <code>EXECUTE</code> <code>IMMEDIATE</code> statement, as follows:</p>
<ul>
<li>
<p>If the dynamic SQL statement is a <code>SELECT</code> statement that can return at most one row, put out-bind arguments (defines) in the <code>INTO</code> clause and in-bind arguments in the <code>USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a <code>SELECT</code> statement that can return multiple rows, put out-bind arguments (defines) in the <code>BULK</code> <code>COLLECT</code> <code>INTO</code> clause and in-bind arguments in the <code>USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a DML statement other than <code>SELECT</code>, without a <code>RETURNING</code> <code>INTO</code> clause, put all bind arguments in the <code>USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a DML statement with a <code>RETURNING</code> <code>INTO</code> clause, put in-bind arguments in the <code>USING</code> clause and out-bind arguments in the <code>RETURNING</code> <code>INTO</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is an anonymous PL/SQL block or a <code>CALL</code> statement, put all bind arguments in the <code>USING</code> clause.</p>
<p>If the dynamic SQL statement invokes a subprogram, ensure that:</p>
<ul>
<li>
<p>Every bind argument that corresponds to a placeholder for a subprogram parameter has the same parameter mode as that subprogram parameter (as in <a href="#CHDIEFCJ">Example 7-1</a>) and a data type that is compatible with that of the subprogram parameter. (For information about compatible data types, see <a href="subprograms.htm#i4100">Formal and Actual Subprogram Parameters</a>.)</p>
</li>
<li>
<p>No bind argument has a data type that SQL does not support (such as <code>BOOLEAN</code> in <a href="#BHCEJIDC">Example 7-2</a>).</p>
</li>
</ul>
</li>
</ul>
<p><a id="sthref858"></a>The <code>USING</code> clause cannot contain the literal <code>NULL</code>. To work around this restriction, use an uninitialized variable where you want to use <code>NULL</code>, as in <a href="#BHCBIICB">Example 7-3</a>.</p>
<p>For syntax details of the <code>EXECUTE</code> <code>IMMEDIATE</code> statement, see <a href="executeimmediate_statement.htm#i33888">EXECUTE IMMEDIATE Statement</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CHDIEFCJ"></a>Example 7-1 Invoking a Subprogram from a Dynamic PL/SQL Block</p>
<pre>
<span class="bold">-- Subprogram that dynamic PL/SQL block invokes:</span>
CREATE PROCEDURE create_dept ( deptid <span class="bold">IN OUT</span> NUMBER,
                               dname  <span class="bold">IN</span> VARCHAR2,
                               mgrid  <span class="bold">IN</span> NUMBER,
                               locid  <span class="bold">IN</span> NUMBER
                             ) AS
BEGIN
</pre>
<pre>
  deptid := departments_seq.NEXTVAL;
  INSERT INTO departments VALUES (deptid, dname, mgrid, locid);
END;
/
DECLARE
  plsql_block VARCHAR2(500);
  new_deptid  NUMBER(4);
  new_dname   VARCHAR2(30) := 'Advertising';
  new_mgrid   NUMBER(6)    := 200;
  new_locid   NUMBER(4)    := 1700;
BEGIN
<span class="bold"> -- Dynamic PL/SQL block invokes subprogram:</span>
  plsql_block := 'BEGIN create_dept(:a, :b, :c, :d); END;';

<span class="bold"> /* Specify bind arguments in USING clause.</span>
<span class="bold">    Specify mode for first parameter.</span>
<span class="bold">    Modes of other parameters are correct by default. */</span>
  EXECUTE IMMEDIATE plsql_block
    USING <span class="bold">IN OUT</span> new_deptid, new_dname, new_mgrid, new_locid;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BHCEJIDC"></a>Example 7-2 Unsupported Data Type in Native Dynamic SQL</p>
<pre>
DECLARE
  FUNCTION f (x INTEGER)
    RETURN BOOLEAN
  AS
  BEGIN
    ...
  END f;
  dyn_stmt VARCHAR2(200);
  b1       BOOLEAN;
BEGIN
  dyn_stmt := 'BEGIN :b := f(5); END;';
  <span class="bold">-- Fails because SQL does not support BOOLEAN data type:</span>
  EXECUTE IMMEDIATE dyn_stmt USING OUT b1;
END;
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BHCBIICB"></a>Example 7-3 Uninitialized Variable for NULL in USING Clause</p>
<pre>
CREATE TABLE employees_temp AS
  SELECT * FROM EMPLOYEES
/
DECLARE
  a_null  CHAR(1);  <span class="bold">-- Set to NULL automatically at run time</span>
BEGIN
  EXECUTE IMMEDIATE 'UPDATE employees_temp SET commission_pct = :x'
    USING <span class="bold">a_null</span>;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i13057"></a>
<div class="sect2">
<h3 class="sect2">Using the OPEN-FOR, FETCH, and CLOSE Statements</h3>
<p><a id="sthref859"></a><a id="sthref860"></a><a id="sthref861"></a>If the dynamic SQL statement represents a <code>SELECT</code> statement that returns multiple rows, you can process it with native dynamic SQL as follows:</p>
<ol>
<li>
<p>Use an <code>OPEN-FOR</code> statement to associate a cursor variable with the dynamic SQL statement. In the <code>USING</code> clause of the <code>OPEN-FOR</code> statement, specify a bind argument for each placeholder in the dynamic SQL statement.</p>
<p>The <code>USING</code> clause cannot contain the literal <code>NULL</code>. To work around this restriction, use an uninitialized variable where you want to use <code>NULL</code>, as in <a href="#BHCBIICB">Example 7-3</a>.</p>
<p>For syntax details, see <a href="openfor_statement.htm#i35231">OPEN-FOR Statement</a>.</p>
</li>
<li>
<p>Use the <code>FETCH</code> statement to retrieve result set rows one at a time, several at a time, or all at once.</p>
<p>For syntax details, see <a href="fetch_statement.htm#i34221">FETCH Statement</a>.</p>
</li>
<li>
<p>Use the <code>CLOSE</code> statement to close the cursor variable.</p>
<p>For syntax details, see <a href="close_statement.htm#i32987">CLOSE Statement</a>.</p>
</li>
</ol>
<p><a href="#BHCFDIAI">Example 7-4</a> lists all employees who are managers, retrieving result set rows one at a time.</p>
<div class="example">
<p class="titleinexample"><a id="BHCFDIAI"></a>Example 7-4 Native Dynamic SQL with OPEN-FOR, FETCH, and CLOSE Statements</p>
<pre>
DECLARE
  TYPE EmpCurTyp  IS REF CURSOR;
  v_emp_cursor    EmpCurTyp;
  emp_record      employees%ROWTYPE;
  v_stmt_str      VARCHAR2(200);
  v_e_job         employees.job%TYPE;
BEGIN
  <span class="bold">-- Dynamic SQL statement with placeholder:</span>
  v_stmt_str := 'SELECT * FROM employees WHERE job_id = :j';

  <span class="bold">-- Open cursor &amp; specify bind argument in USING clause:</span>
  OPEN v_emp_cursor FOR v_stmt_str USING 'MANAGER';

  <span class="bold">-- Fetch rows from result set one at a time:</span>
  LOOP
    FETCH v_emp_cursor INTO emp_record;
    EXIT WHEN v_emp_cursor%NOTFOUND;
  END LOOP;

  <span class="bold">-- Close cursor:</span>
  CLOSE v_emp_cursor;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BHCGEFCA"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Repeating Placeholder Names in Dynamic SQL Statements</h3>
<p>If you repeat placeholder names in dynamic SQL statements, be aware that the way placeholders are associated with bind arguments depends on the kind of dynamic SQL statement.</p>
<p>Topics:</p>
<ul>
<li>
<p><a href="#BHCHIHEJ">Dynamic SQL Statement is Not Anonymous Block or CALL Statement</a></p>
</li>
<li>
<p><a href="#BHCHABFG">Dynamic SQL Statement is Anonymous Block or CALL Statement</a></p>
</li>
</ul>
<a id="BHCHIHEJ"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Dynamic SQL Statement is Not Anonymous Block or CALL Statement</h4>
<p>If the dynamic SQL statement does not represent an anonymous PL/SQL block or a <code>CALL</code> statement, repetition of placeholder names is insignificant. Placeholders are associated with bind arguments in the <code>USING</code> clause by position, not by name.</p>
<p>For example, in the following dynamic SQL statement, the repetition of the name :<code>x</code> is insignificant:</p>
<pre>
sql_stmt := 'INSERT INTO payroll VALUES (:x, :x, :y, :x)';
</pre>
<p>In the corresponding <code>USING</code> clause, you must supply four bind arguments. They can be different; for example:</p>
<pre>
EXECUTE IMMEDIATE sql_stmt USING a, b, c, d;
</pre>
<p>The preceding <code>EXECUTE</code> <code>IMMEDIATE</code> statement executes the following SQL statement:</p>
<pre>
INSERT INTO payroll VALUES (a, b, c, d)
</pre>
<p>To associate the same bind argument with each occurrence of :<code>x</code>, you must repeat that bind argument; for example:</p>
<pre>
EXECUTE IMMEDIATE sql_stmt USING a, a, b, a;
</pre>
<p>The preceding <code>EXECUTE</code> <code>IMMEDIATE</code> statement executes the following SQL statement:</p>
<pre>
INSERT INTO payroll VALUES (a, a, b, a)
</pre></div>
<!-- class="sect3" -->
<a id="BHCHABFG"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Dynamic SQL Statement is Anonymous Block or CALL Statement</h4>
<p>If the dynamic SQL statement represents an anonymous PL/SQL block or a <code>CALL</code> statement, repetition of placeholder names is significant. Each unique placeholder name must have a corresponding bind argument in the <code>USING</code> clause. If you repeat a placeholder name, you need not repeat its corresponding bind argument. All references to that placeholder name correspond to one bind argument in the <code>USING</code> clause.</p>
<p>In <a href="#CHDFHEAG">Example 7-5</a>, all references to the first unique placeholder name, :<code>x</code>, are associated with the first bind argument in the <code>USING</code> clause, <code>a</code>, and the second unique placeholder name, :<code>y</code>, is associated with the second bind argument in the <code>USING</code> clause, <code>b</code>.</p>
<div class="example">
<p class="titleinexample"><a id="CHDFHEAG"></a>Example 7-5 Repeated Placeholder Names in Dynamic PL/SQL Block</p>
<pre>
CREATE PROCEDURE calc_stats (
  w NUMBER,
  x NUMBER,
  y NUMBER,
  z NUMBER )
IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(w + x + y + z);
END;
/
DECLARE
  a NUMBER := 4;
  b NUMBER := 7;
  plsql_block VARCHAR2(100);
BEGIN
  plsql_block := 'BEGIN calc_stats(:x, :x, :y, :x); END;';
  EXECUTE IMMEDIATE plsql_block USING a, b;  <span class="bold">-- calc_stats(a, a, b, a)</span>
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BHCIBJBG"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="LNPLS01108"></a>Using DBMS_SQL Package</h2>
<p><a id="sthref862"></a><a id="sthref863"></a>The <code>DBMS_SQL</code> package defines an entity called a SQL cursor number. Because the SQL cursor number is a PL/SQL integer, you can pass it across call boundaries and store it. You can also use the <a id="sthref864"></a>SQL cursor number to obtain information about the SQL statement that you are executing.</p>
<p>You must use the <code>DBMS_SQL</code> package to execute a dynamic SQL statement when you don't know either of the following until run-time:</p>
<ul>
<li>
<p><code>SELECT</code> list</p>
</li>
<li>
<p>What placeholders in a <code>SELECT</code> or DML statement must be bound</p>
</li>
</ul>
<p>In the following situations, you must use native dynamic SQL instead of the <code>DBMS_SQL</code> package:</p>
<ul>
<li>
<p>The dynamic SQL statement retrieves rows into records.</p>
</li>
<li>
<p><a id="sthref865"></a>You want to use the SQL cursor attribute <code>%FOUND</code>, <code>%ISOPEN</code>, <code>%NOTFOUND</code>, or <code>%ROWCOUNT</code> after issuing a dynamic SQL statement that is an <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, or single-row <code>SELECT</code> statement.</p>
</li>
</ul>
<p>For information about native dynamic SQL, see <a href="#i13130">Using Native Dynamic SQL</a>.</p>
<p><a id="sthref866"></a><a id="sthref867"></a><a id="sthref868"></a><a id="sthref869"></a><a id="sthref870"></a>When you need both the <code>DBMS_SQL</code> package and native dynamic SQL, you can switch between them, using the following:</p>
<ul>
<li>
<p><a href="#BHCECGGF">DBMS_SQL.TO_REFCURSOR Function</a></p>
</li>
<li>
<p><a href="#BHCBJGEH">DBMS_SQL.TO_CURSOR_NUMBER Function</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can invoke <code>DBMS_SQL</code> subprograms remotely.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS058" href="../../appdev.111/b28419/d_sql.htm#ARPLS058"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>DBMS_SQL</code> package, including instructions for executing a dynamic SQL statement that has an unknown number of input or output variables (<a id="sthref871"></a>"Method 4")</div>
<a id="BHCECGGF"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="LNPLS01113"></a>DBMS_SQL.TO_REFCURSOR Function</h3>
<p>The <code>DBMS_SQL</code>.<code>TO_REFCURSOR</code> function converts a SQL cursor number to a weakly-typed variable of the PL/SQL data type <code>REF</code> <code>CURSOR</code>, which you can use in native dynamic SQL statements.</p>
<p>Before passing a SQL cursor number to the <code>DBMS_SQL</code>.<code>TO_REFCURSOR</code> function, you must <code>OPEN</code>, <code>PARSE</code>, and <code>EXECUTE</code> it (otherwise an error occurs).</p>
<p>After you convert a SQL cursor number to a <code>REF</code> <code>CURSOR</code> variable, <code>DBMS_SQL</code> operations can access it only as the <code>REF</code> <code>CURSOR</code> variable, not as the SQL cursor number. For example, using the <code>DBMS_SQL</code>.<code>IS_OPEN</code> function to see if a converted SQL cursor number is still open causes an error.</p>
<p><a href="#g1777282">Example 7-6</a> uses the <code>DBMS_SQL</code>.<code>TO_REFCURSOR</code> function to switch from the <code>DBMS_SQL</code> package to native dynamic SQL.</p>
<div class="example">
<p class="titleinexample"><a id="g1777282"></a>Example 7-6 Switching from DBMS_SQL Package to Native Dynamic SQL</p>
<pre>
CREATE OR REPLACE TYPE vc_array IS TABLE OF VARCHAR2(200);
/
CREATE OR REPLACE TYPE numlist IS TABLE OF NUMBER;
/
CREATE OR REPLACE PROCEDURE do_query_1 (
  placeholder vc_array,
  bindvars vc_array,
  sql_stmt VARCHAR2                    )
IS
  TYPE curtype IS REF CURSOR;
  src_cur      curtype;
  curid        NUMBER;
  bindnames    vc_array;
  empnos       numlist;
  depts        numlist;
  ret          NUMBER;
  isopen       BOOLEAN;
BEGIN
  <span class="bold">-- Open SQL cursor number:</span>
  curid := DBMS_SQL.OPEN_CURSOR;

  <span class="bold">-- Parse SQL cursor number:</span>
  DBMS_SQL.PARSE(curid, sql_stmt, DBMS_SQL.NATIVE);

  bindnames := placeholder;

  -- Bind arguments:
  FOR i IN 1 .. bindnames.COUNT LOOP
    DBMS_SQL.BIND_VARIABLE(curid, bindnames(i), bindvars(i));
  END LOOP;

  <span class="bold">-- Execute SQL cursor number:</span>
  ret := DBMS_SQL.EXECUTE(curid);

  <span class="bold">-- Switch from DBMS_SQL to native dynamic SQL:</span>
  src_cur := DBMS_SQL.TO_REFCURSOR(curid);
  FETCH src_cur BULK COLLECT INTO empnos, depts;

  <span class="bold">-- This would cause an error because curid was converted to a REF CURSOR:</span>
  -- isopen := DBMS_SQL.IS_OPEN(curid);

  CLOSE src_cur;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BHCBJGEH"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="LNPLS00001"></a>DBMS_SQL.TO_CURSOR_NUMBER Function</h3>
<p>The <code>DBMS_SQL</code>.<code>TO_CURSOR</code> function converts a <code>REF</code> <code>CURSOR</code> variable (either strongly or weakly typed) to a SQL cursor number, which you can pass to <code>DBMS_SQL</code> subprograms.</p>
<p>Before passing a <code>REF</code> <code>CURSOR</code> variable to the <code>DBMS_SQL</code>.<code>TO_CURSOR</code> function, you must <code>OPEN</code> it.</p>
<p>After you convert a <code>REF</code> <code>CURSOR</code> variable to a SQL cursor number, native dynamic SQL operations cannot access it.</p>
<p>After a <code>FETCH</code> operation begins, passing the <code>DBMS_SQL</code> cursor number to the <code>DBMS_SQL</code>.<code>TO_REFCURSOR</code> or <code>DBMS_SQL</code>.<code>TO_CURSOR</code> function causes an error.</p>
<p><a href="#BHCHJBHJ">Example 7-7</a> uses the <code>DBMS_SQL</code>.<code>TO_CURSOR</code> function to switch from native dynamic SQL to the <code>DBMS_SQL</code> package.</p>
<div class="example">
<p class="titleinexample"><a id="BHCHJBHJ"></a>Example 7-7 Switching from Native Dynamic SQL to DBMS_SQL Package</p>
<pre>
CREATE OR REPLACE PROCEDURE do_query_2 (sql_stmt VARCHAR2) IS
  TYPE curtype IS REF CURSOR;
  src_cur  curtype;
  curid    NUMBER;
  desctab  DBMS_SQL.DESC_TAB;
  colcnt   NUMBER;
  namevar  VARCHAR2(50);
  numvar   NUMBER;
  datevar  DATE;
  empno    NUMBER := 100;
BEGIN
  -- sql_stmt := SELECT ... FROM employees WHERE employee_id = :b1';

  <span class="bold">-- Open REF CURSOR variable:</span>
  OPEN src_cur FOR sql_stmt USING empno;

  <span class="bold">-- Switch from native dynamic SQL to DBMS_SQL package:</span>
  curid := DBMS_SQL.TO_CURSOR_NUMBER(src_cur);
  DBMS_SQL.DESCRIBE_COLUMNS(curid, colcnt, desctab);

  -- Define columns:
  FOR i IN 1 .. colcnt LOOP
    IF desctab(i).col_type = 2 THEN
      DBMS_SQL.DEFINE_COLUMN(curid, i, numvar);
    ELSIF desctab(i).col_type = 12 THEN
      DBMS_SQL.DEFINE_COLUMN(curid, i, datevar);
      -- statements
    ELSE
      DBMS_SQL.DEFINE_COLUMN(curid, i, namevar, 50);
    END IF;
  END LOOP;

  -- Fetch rows with DBMS_SQL package:
  WHILE DBMS_SQL.FETCH_ROWS(curid) &gt; 0 LOOP
    FOR i IN 1 .. colcnt LOOP
      IF (desctab(i).col_type = 1) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, namevar);
      ELSIF (desctab(i).col_type = 2) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, numvar);
      ELSIF (desctab(i).col_type = 12) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, datevar);
        -- statements
      END IF;
    END LOOP;
  END LOOP;

  DBMS_SQL.CLOSE_CURSOR(curid);
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDFCHHJ"></a>
<div class="sect1">
<h2 class="sect1"><a id="LNPLS01109"></a>Avoiding SQL Injection in PL/SQL</h2>
<p><a id="sthref872"></a><a id="sthref873"></a><a id="sthref874"></a>SQL injection is a technique for maliciously exploiting applications that use client-supplied data in SQL statements, thereby gaining unauthorized access to a database in order to view or manipulate restricted data. This section describes SQL injection vulnerabilities in PL/SQL and explains how to guard against them.</p>
<p>To try the examples in this topic, connect to the <code>HR</code> schema and execute the statements in <a href="#CHDBJCFF">Example 7-8</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CHDBJCFF"></a>Example 7-8 Setup for SQL Injection Examples</p>
<pre>
CREATE TABLE secret_records (
  user_name    VARCHAR2(9),
  service_type VARCHAR2(12),
  value        VARCHAR2(30),
  date_created DATE);

INSERT INTO secret_records
  VALUES ('Andy', 'Waiter', 'Serve dinner at Cafe Pete', SYSDATE);

INSERT INTO secret_records
  VALUES ('Chuck', 'Merger', 'Buy company XYZ', SYSDATE);
</pre></div>
<!-- class="example" -->
<p>Topics:</p>
<ul>
<li>
<p><a href="#BJEEBJAE">Overview of SQL Injection Techniques</a></p>
</li>
<li>
<p><a href="#BJECFFHD">Guarding Against SQL Injection</a></p>
</li>
</ul>
<a id="BJEEBJAE"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Overview of SQL Injection Techniques</h3>
<p>SQL injection techniques differ, but they all exploit a single vulnerability: string input is not correctly validated and is concatenated into a dynamic SQL statement. This topic classifies SQL injection attacks as follows:</p>
<ul>
<li>
<p><a href="#BJEBCDDH">Statement Modification</a></p>
</li>
<li>
<p><a href="#BJEJJDEG">Statement Injection</a></p>
</li>
<li>
<p><a href="#CHDDEBCJ">Data Type Conversion</a></p>
</li>
</ul>
<a id="BJEBCDDH"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Statement Modification</h4>
<p><a id="sthref875"></a><span class="bold">Statement modification</span> means deliberately altering a dynamic SQL statement so that it executes in a way unintended by the application developer. Typically, the user retrieves unauthorized data by changing the <code>WHERE</code> clause of a <code>SELECT</code> statement or by inserting a <code>UNION</code> <code>ALL</code> clause. The classic example of this technique is bypassing password authentication by making a <code>WHERE</code> clause always <code>TRUE</code>.</p>
<p>The SQL*Plus script in <a href="#BJEJABIC">Example 7-9</a> creates a procedure that is vulnerable to statement modification and then invokes that procedure with and without statement modification. With statement modification, the procedure returns a supposedly secret record.</p>
<div class="example">
<p class="titleinexample"><a id="BJEJABIC"></a>Example 7-9 Procedure Vulnerable to Statement Modification</p>
<pre>
SQL&gt; <span class="bold">REM Create vulnerable procedure</span>
SQL&gt;
SQL&gt; CREATE OR REPLACE PROCEDURE get_record
  (user_name    IN  VARCHAR2,
   service_type IN  VARCHAR2,
   record       OUT VARCHAR2)
IS
  query VARCHAR2(4000);
BEGIN
  <span class="bold">-- Following SELECT statement is vulnerable to modification</span>
  <span class="bold">-- because it uses concatenation to build WHERE clause.</span>
  query := 'SELECT value FROM secret_records WHERE user_name='''
           || user_name 
           || ''' AND service_type=''' 
           || service_type 
           || '''';
  DBMS_OUTPUT.PUT_LINE('Query: ' || query);
  EXECUTE IMMEDIATE query INTO record;
  DBMS_OUTPUT.PUT_LINE('Record: ' || record);
END;
/

Procedure created.

SQL&gt; <span class="bold">REM Demonstrate procedure without SQL injection</span>
SQL&gt; 
SQL&gt; SET SERVEROUTPUT ON;
SQL&gt;
SQL&gt; DECLARE
  2    record_value VARCHAR2(4000);
  3  BEGIN
  4    get_record('Andy', 'Waiter', record_value);
  5  END;
  6  /
Query: SELECT value FROM secret_records WHERE user_name='Andy' AND
service_type='Waiter'
Record: Serve dinner at Cafe Pete
 
PL/SQL procedure successfully completed.
 
SQL&gt;
SQL&gt; <span class="bold">REM Example of statement modification</span>
SQL&gt; 
SQL&gt; DECLARE
  2    record_value VARCHAR2(4000);
  3  BEGIN
  4    get_record(
  5      <span class="bold">'Anybody '' OR service_type=''Merger''--',</span>
  6      'Anything',
  7      record_value);
  8  END;
  9  /
<span class="bold">Query: SELECT value FROM secret_records WHERE user_name='Anybody ' OR</span>
<span class="bold">service_type='Merger'--' AND service_type='Anything'</span>
<span class="bold">Record: Buy company XYZ</span>

PL/SQL procedure successfully completed.

SQL&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BJEJJDEG"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Statement Injection</h4>
<p><a id="sthref876"></a><a id="sthref877"></a><span class="bold">Statement injection</span> means that a user appends one or more new SQL statements to a dynamic SQL statement. Anonymous PL/SQL blocks are vulnerable to this technique.</p>
<p>The SQL*Plus script in <a href="#BJEHHAFF">Example 7-10</a> creates a procedure that is vulnerable to statement injection and then invokes that procedure with and without statement injection. With statement injection, the procedure deletes the supposedly secret record exposed in <a href="#BJEJABIC">Example 7-9</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BJEHHAFF"></a>Example 7-10 Procedure Vulnerable to Statement Injection</p>
<pre>
SQL&gt; <span class="bold">REM Create vulnerable procedure</span>
SQL&gt;
SQL&gt; CREATE OR REPLACE PROCEDURE p
  2    (user_name    IN  VARCHAR2,
  3     service_type IN  VARCHAR2)
  4  IS
  5    block VARCHAR2(4000);
  6  BEGIN
  <span class="bold">-- Following block is vulnerable to statement injection</span>
  <span class="bold">-- because it is built by concatenation.</span>
  7    block :=
  8      'BEGIN
  9         DBMS_OUTPUT.PUT_LINE(''user_name: ' || user_name || ''');'
 10         || 'DBMS_OUTPUT.PUT_LINE(''service_type: ' || service_type || ''');
 11       END;';
 12
 13    DBMS_OUTPUT.PUT_LINE('Block: ' || block);
 14
 15    EXECUTE IMMEDIATE block;
 16  END;
 17  /

Procedure created.

SQL&gt;

SQL&gt; <span class="bold">REM Demonstrate procedure without SQL injection</span>
SQL&gt;
SQL&gt; SET SERVEROUTPUT ON;
SQL&gt;
SQL&gt; BEGIN
  2    p('Andy', 'Waiter');
  3  END;
  4  /
Block: BEGIN
         DBMS_OUTPUT.PUT_LINE('user_name: Andy');
         DBMS_OUTPUT.PUT_LINE('service_type: Waiter');
       END;
user_name: Andy
service_type: Waiter

PL/SQL procedure successfully completed.

SQL&gt; <span class="bold">REM Example of statement modification</span>
SQL&gt;
SQL&gt; <span class="bold">SELECT * FROM secret_records;</span>

USER_NAME SERVICE_TYPE VALUE
--------- ------------ ------------------------------
Andy      Waiter       Serve dinner at Cafe Pete
Chuck     Merger       Buy company XYZ
 
<span class="bold">2 rows selected.</span>

SQL&gt;
SQL&gt; BEGIN
  2    p('Anybody', <span class="bold">'Anything'');</span>
  3      <span class="bold">DELETE FROM secret_records WHERE service_type=INITCAP(''Merger'</span>);
  4  END;
  5  /
Block: BEGIN
       DBMS_OUTPUT.PUT_LINE('user_name: Anybody');
       DBMS_OUTPUT.PUT_LINE('service_type: Anything<span class="bold">');</span>
       <span class="bold">DELETE FROM secret_records WHERE service_type=INITCAP('Merger'</span>);
     END;
user_name: Anybody
service_type: Anything

PL/SQL procedure successfully completed.

SQL&gt; <span class="bold">SELECT * FROM secret_records;</span>

USER_NAME SERVICE_TYPE VALUE
--------- ------------ ------------------------------
Andy      Waiter       Serve dinner at Cafe Pete
 
<span class="bold">1 row selected.</span>

SQL&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDDEBCJ"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Data Type Conversion</h4>
<p><a id="sthref878"></a><a id="sthref879"></a>A less known SQL injection technique uses NLS session parameters to modify or inject SQL statements.</p>
<p>A datetime or numeric value that is concatenated into the text of a dynamic SQL statement must be converted to the <code>VARCHAR2</code> data type. The conversion can be either implicit (when the value is an operand of the concatentation operator) or explicit (when the value is the argument of the <code>TO_CHAR</code> function). This data type conversion depends on the NLS settings of the database session that executes the dynamic SQL statement. The conversion of datetime values uses format models specified in the parameters <code>NLS_DATE_FORMAT</code>, <code>NLS_TIMESTAMP_FORMAT</code>, or <code>NLS_TIMESTAMP_TZ_FORMAT</code>, depending on the particular datetime data type. The conversion of numeric values applies decimal and group separators specified in the parameter <code>NLS_NUMERIC_CHARACTERS</code>.</p>
<p>One datetime format model is <code>"</code><code><span class="codeinlineitalic">text</span></code><code>"</code>. The <code><span class="codeinlineitalic">text</span></code> is copied into the conversion result. For example, if the value of <code>NLS_DATE_FORMAT</code> is <code>'"Month:" Month'</code>, then in June, <code>TO_CHAR(SYSDATE)</code> returns <code>'Month: June'</code>. The datetime format model can be abused as shown in <a href="#CHDEIABG">Example 7-11</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CHDEIABG"></a>Example 7-11 Procedure Vulnerable to SQL Injection Through Data Type Conversion</p>
<pre>
SQL&gt; <span class="bold">REM Create vulnerable procedure</span>
SQL&gt; REM Return records not older than a month
SQL&gt;
SQL&gt; CREATE OR REPLACE PROCEDURE get_recent_record
  (user_name    IN  VARCHAR2,
   service_type IN  VARCHAR2,
   record       OUT VARCHAR2)
IS
  query VARCHAR2(4000);
BEGIN
  <span class="bold">-- Following SELECT statement is vulnerable to modification</span>
  <span class="bold">-- because it uses concatenation to build WHERE clause</span>
  <span class="bold">-- and because SYSDATE depends on the value of NLS_DATE_FORMAT.</span>
  query := 'SELECT value FROM secret_records WHERE user_name='''
           || user_name
           || ''' AND service_type='''
           || service_type
           || ''' AND date_created&gt;'''
           || <span class="bold">(SYSDATE - 30)</span>
           || '''';
  DBMS_OUTPUT.PUT_LINE('Query: ' || query);
  EXECUTE IMMEDIATE query INTO record;
  DBMS_OUTPUT.PUT_LINE('Record: ' || record);
END;
/ 
. 
Procedure created.
. 
SQL&gt; <span class="bold">REM Demonstrate procedure without SQL injection</span>
SQL&gt;
SQL&gt; SET SERVEROUTPUT ON;
SQL&gt;
SQL&gt; <span class="bold">ALTER SESSION SET NLS_DATE_FORMAT='DD-MON-YYYY';</span>
. 
Session altered.
. 
SQL&gt; DECLARE
  2    record_value VARCHAR2(4000);
  3  BEGIN
  4    get_recent_record('Andy', 'Waiter', record_value);
  5  END;
  6  /
Query: SELECT value FROM secret_records WHERE user_name='Andy' AND
service_type='Waiter' AND date_created&gt;'27-MAY-2008'
Record: Serve dinner at Cafe Pete
  
PL/SQL procedure successfully completed.
  
SQL&gt;
SQL&gt; <span class="bold">REM Example of statement modification</span>
SQL&gt;
SQL&gt; <span class="bold">ALTER SESSION SET NLS_DATE_FORMAT='"'' OR service_type=''Merger"';</span>
. 
Session altered.
. 
SQL&gt; DECLARE
  2    record_value VARCHAR2(4000);
  3  BEGIN
  4    get_recent_record('Anybody', 'Anything', record_value);
  5  END;
  6  /
<span class="bold">Query: SELECT value FROM secret_records WHERE user_name='Anybody' AND</span>
<span class="bold">service_type='Anything' AND date_created&gt;'' OR service_type='Merger'</span>
<span class="bold">Record: Buy company XYZ</span>
. 
PL/SQL procedure successfully completed.
. 
SQL&gt; 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BJECFFHD"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Guarding Against SQL Injection</h3>
<p>If you use dynamic SQL in your PL/SQL applications, you must check the input text to ensure that it is exactly what you expected. You can use the following techniques:</p>
<ul>
<li>
<p><a href="#BJEDAHEE">Using Bind Arguments to Guard Against SQL Injection</a></p>
</li>
<li>
<p><a href="#BJEICDDJ">Using Validation Checks to Guard Against SQL Injection</a></p>
</li>
<li>
<p><a href="#CHDGICJH">Using Explicit Format Models to Guard Against SQL Injection</a></p>
</li>
</ul>
<a id="BJEDAHEE"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using Bind Arguments to Guard Against SQL Injection</h4>
<p><a id="sthref880"></a>The most effective way to make your PL/SQL code invulnerable to SQL injection attacks is to use bind arguments. The database uses the values of bind arguments exclusively and does not interpret their contents in any way. (Bind arguments also improve performance.)</p>
<p>The procedure in <a href="#BJEIJEBJ">Example 7-12</a> is invulnerable to SQL injection because it builds the dynamic SQL statement with bind arguments (not by concatenation as in the vulnerable procedure in <a href="#BJEJABIC">Example 7-9</a>). The same binding technique fixes the vulnerable procedure shown in <a href="#BJEHHAFF">Example 7-10</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BJEIJEBJ"></a>Example 7-12 Using Bind Arguments to Guard Against SQL Injection</p>
<pre>
SQL&gt; <span class="bold">REM Create invulnerable procedure</span>
SQL&gt; 
SQL&gt; CREATE OR REPLACE PROCEDURE get_record_2
  2    (user_name    IN  VARCHAR2,
  3     service_type IN  VARCHAR2,
  4     record       OUT VARCHAR2)
  5  IS
  6    query VARCHAR2(4000);
  7  BEGIN
  8    query := 'SELECT value FROM secret_records
  9              WHERE user_name=<span class="bold">:a</span>
 10              AND service_type=<span class="bold">:b</span>';
 11  
 12    DBMS_OUTPUT.PUT_LINE('Query: ' || query);
 13  
 14    EXECUTE IMMEDIATE query INTO record <span class="bold">USING user_name, service_type</span>;
 15  
 16    DBMS_OUTPUT.PUT_LINE('Record: ' || record);
 17  END;
 18  /
 
Procedure created.
 
SQL&gt; <span class="bold">REM Demonstrate procedure without SQL injection</span>
SQL&gt; 
SQL&gt; SET SERVEROUTPUT ON;
SQL&gt; 
SQL&gt; DECLARE
  2    record_value VARCHAR2(4000);
  3  BEGIN
  4    get_record_2('Andy', 'Waiter', record_value);
  5  END;
  6  /
Query: SELECT value FROM secret_records
            WHERE user_name=<span class="bold">:a</span>
            AND service_type=<span class="bold">:b</span>
Record: Serve dinner at Cafe Pete
 
PL/SQL procedure successfully completed.
 
SQL&gt; 
SQL&gt; <span class="bold">REM Attempt statement modification</span>
SQL&gt; 
SQL&gt; DECLARE
  2    record_value VARCHAR2(4000);
  3  BEGIN
  4    get_record_2('Anybody '' OR service_type=''Merger''--',
  5                 'Anything',
  6                 record_value);
  7  END;
  8  /
Query: SELECT value FROM secret_records
            WHERE user_name=<span class="bold">:a</span>
            AND service_type=<span class="bold">:b</span>
DECLARE
*
<span class="bold">ERROR at line 1:</span>
<span class="bold">ORA-01403: no data found</span>
<span class="bold">ORA-06512: at "HR.GET_RECORD_2", line 14</span>
<span class="bold">ORA-06512: at line 4</span>
 
SQL&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BJEICDDJ"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using Validation Checks to Guard Against SQL Injection</h4>
<p><a id="sthref881"></a>Always have your program validate user input to ensure that it is what is intended. For example, if the user is passing a department number for a <code>DELETE</code> statement, check the validity of this department number by selecting from the <code>departments</code> table. Similarly, if a user enters the name of a table to be deleted, check that this table exists by selecting from the static data dictionary view <code>ALL_TABLES</code>.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
When checking the validity of a user name and its password, always return the same error regardless of which item is invalid. Otherwise, a malicious user who receives the error message "invalid password" but not "invalid user name" (or the reverse) will realize that he or she has guessed one of these correctly.</div>
<p><a id="sthref882"></a>In validation-checking code, the subprograms in the package <code>DBMS_ASSERT</code> are often useful. For example, you can use the <code>DBMS_ASSERT</code>.<code>ENQUOTE_LITERAL</code> function to enclose a string literal in quotation marks, as <a href="#CHDGJEGD">Example 7-13</a> does. This prevents a malicious user from injecting text between an opening quotation mark and its corresponding closing quotation mark.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Although the <code>DBMS_ASSERT</code> subprograms are useful in validation code, they do not replace it. For example, an input string can be a qualified SQL name (verified by <code>DBMS_ASSERT</code>.<code>QUALIFIED_SQL_NAME</code>) and still be a fraudulent password.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS231" href="../../appdev.111/b28419/d_assert.htm#ARPLS231"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about <code>DBMS_ASSERT</code> subprograms</div>
<p>In <a href="#CHDGJEGD">Example 7-13</a>, the procedure <code>raise_emp_salary</code> checks the validity of the column name that was passed to it before it updates the <code>employees</code> table, and then the anonymous PL/SQL block invokes the procedure from both a dynamic PL/SQL block and a dynamic SQL statement.</p>
<div class="example">
<p class="titleinexample"><a id="CHDGJEGD"></a>Example 7-13 Using Validation Checks to Guard Against SQL Injection</p>
<pre>
CREATE OR REPLACE PROCEDURE raise_emp_salary (
  column_value  NUMBER,
  emp_column    VARCHAR2,
  amount NUMBER                              )
IS
  v_column  VARCHAR2(30);
  sql_stmt  VARCHAR2(200);
BEGIN
  <span class="bold">-- Check validity of column name that was given as input:</span>
  SELECT COLUMN_NAME INTO v_column
    FROM USER_TAB_COLS
      WHERE TABLE_NAME = 'EMPLOYEES'
        AND COLUMN_NAME = emp_column;
  sql_stmt := 'UPDATE employees SET salary = salary + :1 WHERE '
    || <span class="bold">DBMS_ASSERT.ENQUOTE_NAME(v_column,FALSE)</span> || ' = :2';
  EXECUTE IMMEDIATE sql_stmt USING amount, column_value;
  <span class="bold">-- If column name is valid:</span>
  IF SQL%ROWCOUNT &gt; 0 THEN
    DBMS_OUTPUT.PUT_LINE('Salaries were updated for: '
      || emp_column || ' = ' || column_value);
  END IF;
  <span class="bold">-- If column name is not valid:</span>
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE ('Invalid Column: ' || emp_column);
END raise_emp_salary;
/

DECLARE
  plsql_block  VARCHAR2(500);
BEGIN
  <span class="bold">-- Invoke raise_emp_salary from a dynamic PL/SQL block:</span>
  plsql_block :=
    'BEGIN raise_emp_salary(:cvalue, :cname, :amt); END;';
  EXECUTE IMMEDIATE plsql_block
    USING 110, 'DEPARTMENT_ID', 10;

  <span class="bold">-- Invoke raise_emp_salary from a dynamic SQL statement:</span>
  EXECUTE IMMEDIATE 'BEGIN raise_emp_salary(:cvalue, :cname, :amt); END;'
    USING 112, 'EMPLOYEE_ID', 10;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDGICJH"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using Explicit Format Models to Guard Against SQL Injection</h4>
<p><a id="sthref883"></a><a id="sthref884"></a>If you use datetime and numeric values that are concatenated into the text of a SQL or PL/SQL statement, and you cannot pass them as bind variables, convert them to text using explicit format models that are independent from the values of the NLS parameters of the executing session. Ensure that the converted values have the format of SQL datetime or numeric literals. Using explicit locale-independent format models to construct SQL is recommended not only from a security perspective, but also to ensure that the dynamic SQL statement runs correctly in any globalization environment.</p>
<p>The procedure in <a href="#CHDFIIEF">Example 7-14</a> is invulnerable to SQL injection because it converts the datetime parameter value, <code>SYSDATE</code> <code>-</code> <code>30</code>, to a <code>VARCHAR2</code> value explicitly, using the <code>TO_CHAR</code> function and a locale-independent format model (not implicitly, as in the vulnerable procedure in <a href="#CHDEIABG">Example 7-11</a>).</p>
<div class="example">
<p class="titleinexample"><a id="CHDFIIEF"></a>Example 7-14 Using Explicit Format Models to Guard Against SQL Injection</p>
<pre>
SQL&gt; <span class="bold">REM Create invulnerable procedure</span> 
SQL&gt; REM Return records not older than a month 
SQL&gt; 
SQL&gt; CREATE OR REPLACE PROCEDURE get_recent_record 
  (user_name    IN  VARCHAR2, 
   service_type IN  VARCHAR2, 
   record       OUT VARCHAR2) 
IS 
  query VARCHAR2(4000); 
BEGIN 
  -- Following SELECT statement is vulnerable to modification 
  -- because it uses concatenation to build WHERE clause. 
  query := 'SELECT value FROM secret_records WHERE user_name=''' 
           || user_name 
           || ''' AND service_type=''' 
           || service_type 
           || ''' AND date_created&gt; DATE ''' 
           || <span class="bold">TO_CHAR(SYSDATE - 30,'YYYY-MM-DD'</span>) 
           || ''''; 
  DBMS_OUTPUT.PUT_LINE('Query: ' || query); 
  EXECUTE IMMEDIATE query INTO record; 
  DBMS_OUTPUT.PUT_LINE('Record: ' || record); 
END; 
/ 
. 
Procedure created. 
. 
SQL&gt; 
SQL&gt; <span class="bold">REM Attempt statement modification</span> 
SQL&gt; 
SQL&gt; <span class="bold">ALTER SESSION SET NLS_DATE_FORMAT='"'' OR service_type=''Merger"';</span> 
. 
Session altered. 
. 
SQL&gt; DECLARE 
  2    record_value VARCHAR2(4000); 
  3  BEGIN 
  4    get_recent_record('Anybody', 'Anything', record_value); 
  5  END; 
  6  / 
<span class="bold">Query: SELECT value FROM secret_records WHERE user_name='Anybody' AND</span> 
<span class="bold">service_type='Anything' AND date_created&gt; DATE '2008-05-27'</span> 
<span class="bold">DECLARE</span> 
<span class="bold">*</span> 
<span class="bold">ERROR at line 1:</span> 
<span class="bold">ORA-01403: no data found</span> 
<span class="bold">ORA-06512: at "SYS.GET_RECENT_RECORD", line 18</span> 
<span class="bold">ORA-06512: at line 4</span> 
. 
SQL&gt; 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2091">
<tr>
<td class="cellalignment2100">
<table class="cellalignment2096">
<tr>
<td class="cellalignment2095"><a href="static.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2095"><a href="subprograms.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2103">
<table class="cellalignment2094">
<tr>
<td class="cellalignment2095"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2095"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2095"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2095"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2095"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2095"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
