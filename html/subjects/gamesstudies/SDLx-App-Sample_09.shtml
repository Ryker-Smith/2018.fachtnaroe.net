<!DOCTYPE html>
<!--#include virtual="/includes/head.shtml" -->
<body onload="onloadProc()">
<!--#include virtual="/includes/inprogress.shtml" -->
<!--#include virtual="/includes/animation.shtml" -->
<div id="pagewrap">
<!--#include virtual="/includes/sitename.shtml" -->
<div id="topstripe"></div>
<!--#include virtual="/includes/sidemenu.shtml" -->
<div id="content">
<!--#include virtual="/includes/topblurb.shtml" -->
<h1>Multiple badguys, multiple projectiles</h1>
<p>This code sample uses and re-uses a simple idea.</p>
<p>Each enemy is created in a hash array, with it's own (X,Y) co-ordinates, images etc. Then the structure is pushed into an array. The advantage of this is that we can then use a <b>foreach</b> to iterate over the array, doing whatever needs to be done with each badguy.</p>
<p>(Technically, these are pointers to data, but let's ignore that for now)</p>
<p>The badguy move handler iterates over the data and updates each items location. The badguy show handler iterates over the data and updates the screen for each item.</p>
<p>When we need to add another badguy, we can <b>push</b> it into the array. When we destroy a badguy, we can <b>splice</b> the array to remove the badguys data.</p>
<p>The real beauty of this method is that we can copy it for other objects in the game, without the game becoming overly complex.</p>
<p>In this sample, there are multiple badguys, multiple projectiles. There is even different types of projectiles. This all means lots of collision detection, as you can see in the <b>moveRocket</b> subroutine.</p>
<p>This code also shows how to use multiple channels to allow multiple sound effects at once.</p>
<pre>
...SNIP
# This code makes extensive use of the splice function
# read more about splice here: <a href="http://perldoc.perl.org/functions/splice.html">http://perldoc.perl.org/functions/splice.html</a>

# The object of this code is to have multiple enemy objects, multiple projectiles,
# and to handle multiple collisions.

# add some house-keeping handlers
$app-&gt;add_show_handler(\&amp;scoreUpdate);
$app-&gt;add_show_handler(\&amp;showLives);

#### loop to create random enemies #######
# the enemies are pushed into an array after creation
for (my $i=0; $i&lt;$maxEnemy; $i++) {
  # first create an empty data structure
  $object={};
  $object-&gt;{image}=$objectImage;
  $object-&gt;{x}= randStartEnemyX();
  $object-&gt;{y} = randStartEnemyY();
  $object-&gt;{rect}= SDL::Rect-&gt;new($object-&gt;{x}, $object-&gt;{y}, $object-&gt;{image}-&gt;w, $object-&gt;{image}-&gt;h);;
  push @allEnemies, $object;
}
# event handlers
$app-&gt;add_event_handler(\&amp;quit_event);
$app-&gt;add_event_handler(\&amp;key_event);

#### Move handlers ############################
$app-&gt;add_move_handler(\&amp;playerCollisions);
$app-&gt;add_show_handler(\&amp;showHero);

$app-&gt;add_move_handler(\&amp;moveEnemy);
$app-&gt;add_show_handler(\&amp;showEnemy);

$missileMoveHandle = $app-&gt;add_move_handler(\&amp;moveRocket);
$missileShowHandle = $app-&gt;add_show_handler(\&amp;showRocket);
# we can animate the explosions as required
$app-&gt;add_show_handler(\&amp;showExplosion);
$app-&gt;add_show_handler(sub{$app-&gt;sync()}); #Sync must always run LAST
#### Start the game loop ######################
$app-&gt;run;

################## SUBROUTINES ################

sub key_event {
  my ($event, $app) = @_;
  my $key_name = SDL::Events::get_key_name( $event-&gt;key_sym );  

  if (($key_name eq "x") || ($key_name eq "X") ) {
    $app-&gt;stop;
  }
  ...SNIP
  elsif ($key_name eq "p") {
    $app-&gt;pause();
  }
  ...SNIP
  # using 'space' as firebutton 1
  elsif ($key_name eq "space") {
    # raise a flag
    $firing = 1; 
    ###################AUDIO#############################
    # play on channel 2, 1 time (0 means once, -1 means loop)
    # make some noise
    SDL::Mixer::Channels::play_channel( 3, $machineGun, 0 );
    ###################END AUDIO ADDITION#############################
    # the laser is fired by the hero, calculate start point from that
    my $rocket-&gt;{x} = $heroX + int ($hero-&gt;w/2); #
    $rocket-&gt;{image}=$laser;
    $rocket-&gt;{thing}='laser';
    $rocket-&gt;{y}= $heroY ;
    $rocket-&gt;{oldX}=$rocket-&gt;{x};
    $rocket-&gt;{oldY}=$rocket-&gt;{y};
    push @allRockets, $rocket;
  }
  # using 'k' as firebutton 2 but could be anything
  elsif ($key_name eq "k") {
    
    # raise a flag
    $firing = 1; 
    ###################AUDIO#############################
    # play on channel 2, 1 time (0 means once, -1 means loop)
    # make some noise
    SDL::Mixer::Channels::play_channel( 3, $airmissile, 0 );
    ###################END AUDIO ADDITION#############################
    # the laser is fired by the hero, calculate start point from hero's location
    my $rocket-&gt;{x} = $heroX + int ($hero-&gt;w/2-9);
    $rocket-&gt;{image}=$rocket;
    $rocket-&gt;{thing}='rocket';
    $rocket-&gt;{y}= $heroY ;
    $rocket-&gt;{oldX}=$rocket-&gt;{x};
    $rocket-&gt;{oldY}=$rocket-&gt;{y};
    push @allRockets, $rocket;
  }
}
######################################################
sub moveRocket {
  my ($step, $app, $t) = @_;
  # my arbitrary distance for a hit
  my $blast_radius = 20;
  my $countRocket=0;
  foreach my $projectile (@allRockets) {
    ($projectile-&gt;{oldX},$projectile-&gt;{oldY})=($projectile-&gt;{x}, $projectile-&gt;{y});
    if ($projectile-&gt;{y} &gt; -50) {
      # move laser by whatever amt we wish
      $projectile-&gt;{y} -= 10;
      my $countPlane=0;
      my ($rX, $rY) = ($projectile-&gt;{x}, $projectile-&gt;{y});
      foreach my $thing (@allEnemies) {
        my ($enemy_x, $enemy_y) = ($thing-&gt;{x}, $thing-&gt;{y});
        # call our distance measuring routine
        if (&amp;distance_is($rX, $rY, $enemy_x, $enemy_y) &lt; $blast_radius) {
          print "Bang: Direct Hit\n";
          ###################END AUDIO ADDITION#############################
          # play on channel 2, 1 time (0 means once, -1 means loop)
          SDL::Mixer::Channels::play_channel( 2, $explodyFace, 0 );
          ###################END AUDIO ADDITION#############################
          $score+=30;
          # hit, change image
          $thing-&gt;{image}=$explosionImage;
          # save in differen variable
          $explodyThing=$thing;
          $explodyThing-&gt;{type}='plane';
          $explodyThing-&gt;{steps}=10; # some value to represent count of steps in explosion
          # save into explosions array for later processing
          push @explosionsList, $explodyThing;
          # remove from enemy planes array
          splice (@allEnemies, $countPlane, 1);
          # remove missile from projectiles array
          splice (@allRockets, $countRocket, 1);
          #
          if (scalar @allEnemies == 0) {
            sleep(2);
	    SDL::Mixer::Channels::play_channel( 3, $hawkings, 0 );
	    sleep(2);
	    $app-&gt;stop;
          }
          $firing=0;
        }
        $countPlane++;
      }
    }
    # keep count of projectile number in array
    $countRocket++;
  }
}
##################################################################
sub showRocket {
  my ($delta, $app) = @_;
  # do the drawing stuff for the players projectile.
  # This show handler will be added and removed (enabled/disabled)
  # as required by our code-
  my ($master, $new_laser_rect, $coverRect);
  foreach my $thing (@allRockets) {
    my ($X, $Y) = ($thing-&gt;{x}, $thing-&gt;{y});
    my ($oldX, $oldY) = ($thing-&gt;{oldX},$thing-&gt;{oldY} );
    print "Firing: ",$thing-&gt;{thing},"\n";
    # this is a work-around to enable handling of different projectile images
    if ($thing-&gt;{thing} eq 'laser') {
      $object=$laser;
      $master=$laserMaster;
    }
    else {
      $object=$rocket;
      $master=$rocketMaster;
    }
    $coverRect = SDL::Rect-&gt;new($oldX, $oldY, $object-&gt;w, $object-&gt;h);
    SDL::Video::blit_surface( $cover, $coverRect, $app, $coverRect );
    $new_laser_rect = SDL::Rect-&gt;new($X,$Y,$object-&gt;w,$object-&gt;h);
    SDL::Video::blit_surface ( $object, $master, $app, $new_laser_rect);
  }
}
##################################################################
sub showHero {
  # show good guy
  my ($delta, $app) = @_;
  my ($new_ship_rect, $coverRect);
  $coverRect = SDL::Rect-&gt;new($old_ship_x, $old_ship_y, $hero-&gt;w, $hero-&gt;h);
  SDL::Video::blit_surface( $cover, $coverRect, $app, $coverRect );
  $new_ship_rect = SDL::Rect-&gt;new($heroX,$heroY,$hero-&gt;w,$hero-&gt;h);
  SDL::Video::blit_surface ( $hero, $heroMaster, $app, $new_ship_rect);
}
##################################################################
sub moveEnemy {
  my ($step, $app, $t) = @_;
  # for each enemy previously created and pushed into our array of bad guys:
  foreach my $thing (@allEnemies) {
    # change coordinates
    $thing-&gt;{old_enemy_y}=$thing-&gt;{y};
    $thing-&gt;{old_enemy_x}=$thing-&gt;{x};
    # add the step move amount
    $thing-&gt;{y} += enemySpeed;
    # at bottom of screen, start again
    if ($thing-&gt;{y} &gt; bottomLimit) {
      $thing-&gt;{y} = randStartEnemyY();
      $thing-&gt;{x} = randStartEnemyX();
    }
  }
}
##################################################################
sub showEnemy {
  my ($delta, $app) = @_;
  # loop through the array with handles for all the enemies
  foreach my $thing (@allEnemies) {
    # get image coordinates into nicer looking variables
    my ($enemy_x, $enemy_y) = ($thing-&gt;{x}, $thing-&gt;{y});
    my ($old_enemy_x, $old_enemy_y) = ($thing-&gt;{old_enemy_x},$thing-&gt;{old_enemy_y} );
    # get the image associated with the object
    my $object = $thing-&gt;{image};
    # animate only if enemy has moved
    if (($enemy_x != $old_enemy_x) || ($enemy_y != $old_enemy_y)) {
      $coverRect = SDL::Rect-&gt;new($old_enemy_x, $old_enemy_y, $object-&gt;w, $object-&gt;h);
      SDL::Video::blit_surface( $cover, $coverRect, $app, $coverRect );
      $new_enemy_rect = SDL::Rect-&gt;new($enemy_x,$enemy_y,$object-&gt;w,$object-&gt;h);
      SDL::Video::blit_surface( $object, $objectMaster, $app, $new_enemy_rect);
    }
  }
}

sub showExplosion {
  # we can animate the explosions, if required. This can be used for 
  # extra gory bits if needed. eg people falling from planes, lumps of
  # exploding animal etc.
  my ($delta, $app) = @_;
  my $count=0;
  foreach my $thing (@explosionsList) {
    # get image coordinates into nicer looking variables
    my ($explosionX, $explosionY) = ($thing-&gt;{x}, $thing-&gt;{y});
    my ($oldExplosionX, $oldExplosionY) = ($thing-&gt;{old_enemy_x},$thing-&gt;{old_enemy_y} );
    my $object = $thing-&gt;{image};
    if (($explosionX != $oldExplosionX) || ($explosionY != $oldExplosionY)) {
      $coverRect = SDL::Rect-&gt;new($oldExplosionX, $oldExplosionY, $object-&gt;w, $object-&gt;h);
      SDL::Video::blit_surface( $cover, $coverRect, $app, $coverRect );
      $new_enemy_rect = SDL::Rect-&gt;new($explosionX,$explosionY,$object-&gt;w,$object-&gt;h);
      SDL::Video::blit_surface( $object, $objectMaster, $app, $new_enemy_rect);
    }
    # we're using a counter to keep track of the stages of the explosion. Decrement here
    $thing-&gt;{steps} --;
    # at end of explosion sequence, remove explosion from array using splice
    if ($thing-&gt;{steps} == 0) {
      $coverRect = SDL::Rect-&gt;new($oldExplosionX, $oldExplosionY, $object-&gt;w, $object-&gt;h);
      SDL::Video::blit_surface( $cover, $coverRect, $app, $coverRect );
      splice (@explosionsList, $count, 1);
    }
    $count++;
  }
}
#################################################################
# what it says on the tin
sub randStartEnemyX {
  return int(rand(screenWidth-5))+5;
}
sub randStartEnemyY {
  my $y=int(rand(200));
  return (0-$y);
}
#################################################################
sub distance_is {
  # this isn't a handler; this is just a sub to calc.
  # the distance between an (object, thing).
  # the object can be a projectile, the thing can be a
  # hero or enemy
  # Usage: &amp;distance_is (X1, Y1, X2, Y2)
  my ($objectX1, $objectY1, $thingX2, $thingY2) = @_;
  # formula for distance between  two points is:
  # square root of (square(X2 - X1) + square(Y2 - Y1))
  # Using the object as point #1, bad guy as point #2
  my $distance = sqrt (($thingX2 - $objectX1)**2 + ($thingY2 - $objectY1)**2);
  # I don't mind the decimals for now
  $distance=int($distance);
  # for debuggin
  #print "[$distance]\n";
  return $distance;
}
##################################################################
  
sub playerCollisions {
  my ($step, $app, $t) = @_;
  my ($objectcenterX, $objectcenterY, $pos);
  # this may be kludgy ...SNIP
  $pos=0; # count position in array
  foreach my $thing (@allEnemies) {
    #if ($thing != ()) {};
    # get image coordinates into nicer looking variables
    my ($objectX, $objectY) = ($thing-&gt;{x}, $thing-&gt;{y});
    # Using formula for distance between two points
    my $distance = sqrt (($objectX - $heroX)**2 + ($objectY - $heroY)**2);
    $distance=int($distance);
    # are we hit? Can we die if so?
    if (($distance &lt; some_basic_value) &amp;&amp; (canDie)) {
      $lives--;
      # restart from start location
      $heroX = heroStartX;
      $heroY = heroStartY;
      # update screen
      showLives();
      # show collision message
      SDL::Video::blit_surface ( $collisionBanner, $collisionMaster, $app, $collisionRect);
      SDL::Video::update_rects( $app, $collisionRect);
      # if more than one array element (enemy), use splice to remove the
      # one we've just hit
      if (scalar @allEnemies &gt; 1) {
	# splice nicely
        splice @allEnemies, $pos ,1;
      }
      # pause for applause
      $app-&gt;pause;
      if ($lives == 0) {
        print "You're DEAD !!!!!\n";
        #print "Your score was $score\n";
        SDL::Video::blit_surface( $background, $backgroundRect, $app, $backgroundRect);
        $app-&gt;stop;
      }
      else {
        # if we're not dead, then hop out of loop cleanly
        last;
      }
    }
  }
  # keep track of position in the array
  $pos++;
}
</pre>
<small><!--#config timefmt="%Y%m%d-%H:%M" -->Last updated: <!--#flastmod file="SDLx-App-Sample_09.shtml" --></small>
</div> <!-- #content -->
<!--#include virtual="/includes/backtotop.shtml" -->
</div> <!-- #pagewrap -->
</body>
</html>
