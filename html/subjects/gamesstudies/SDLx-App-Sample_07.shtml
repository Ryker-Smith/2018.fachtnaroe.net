<!DOCTYPE html>
<!--#include virtual="/includes/head.shtml" -->
<body onload="onloadProc()">
<!--#include virtual="/includes/inprogress.shtml" -->
<!--#include virtual="/includes/animation.shtml" -->
<div id="pagewrap">
<!--#include virtual="/includes/sitename.shtml" -->
<div id="topstripe"></div>
<!--#include virtual="/includes/sidemenu.shtml" -->
<div id="content">
<!--#include virtual="/includes/topblurb.shtml" -->
<h1>Simple navigation testing/collision detection using pixel color</h1>
<p>This sample shows a simple color based navigation testing method. This presumes that the game is 2D with a simple background that is suitable for use in this manner.</p>
<p>Note that pixel based collision detection is more intensive than other alternatives, and is not suitable for all games.</p>
<pre>
...SNIP
sub move_badguy {
  # Calculate where the bad guy should be, test the coordinate,
  # if move is OK new co-ords will be used to re-draw at the new location
  #
  my ($step, $app, $t) = @_;
  my ($direction, $moving, $path_color, $test);
  $path_color=16316153; # whatever color is allowed for navigation
  $moving=0;
  # store x,y for later use
  $old_x = $badguy_x;
  $old_y = $badguy_y;
...
  # if we're trying to move left
  $badguy_x -= $badguy_step*$step;
  $test=SDL::Surface::get_pixel($app, $background-&gt;w*$badguy_y+$badguy_x);
  if ($test==$path_color) {
    $moving=1; # good future location, we'll allow the move
  }
...
  if ($moving==0) {
    # swap back the earlier x,y if move isn't allowed
    $badguy_x = $old_x;
    $badguy_y = $old_y;
  }
...  
}  
...SNIP...

...SNIP...
sub show_badguy {
  # Draw the bad guy
  my ($delta, $app) = @_;
  if (($badguy_x != $old_x) || ($badguy_y != $old_y)) {
    # BadLad has moved so do what needs doing...
    
  }    
}
...SNIP...
</pre>
<small><!--#config timefmt="%Y%m%d-%H:%M" -->Last updated: <!--#flastmod file="SDLx-App-Sample_07.shtml" --></small>
</div> <!-- #content -->
<!--#include virtual="/includes/backtotop.shtml" -->
</div> <!-- #pagewrap -->
</body>
</html>
