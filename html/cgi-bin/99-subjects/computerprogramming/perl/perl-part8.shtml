<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
 <title>Central Technical Institute Intranet</title>
	<link rel="stylesheet" type="text/css" media="screen" href="/style.css" />
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
<a name="top"></a>
<div class="hide">Skip to:<a href="#info">content</a>, <a href="#navigation">navigation</a></div>
<div id="logo"><h1>CTI-Clonmel Intranet</h1></div><br clear="all" />
<div id="nav">
<ul>
	<li>Tools</li>
	<li class="mail"><a href="https://mail.cti-clonmel.ie/cgi-bin/openwebmail/openwebmail.pl">Web Mail</a></li>
	<li class="cal"><a href="http://webmail.cti-clonmel.ie/cgi-bin/events/event-list.pl#today">Calendar</a></li>
	<li class="search"><a href="http://www.google.ie">Internet Search</a></li>
	<li class="password"><a href="http://193.120.102.192:81/cgi-bin/changepassword.cgi">Password Change</a></li>
	<li class="help"><a href="/help">Help</a></li>
</ul>
<ul>
	<li class="material"><a href="/subjects/subjectsmain.html">Course Material</a></li>
</ul>
</div>
<div id="content">
<h1>Perl - Part 8</h1>
<!--#exec cgi="/cgi-bin/shtml/navigate.shtml" -->
<h2>Perl Input and Output</h2>
<h3>Perl has the ability to read files from disk as easy, if not easier than any other known programming language. However, what you've seen of <i>keyboard</i> input thus far has been somewhat cumbersome. You had to <b>use</b> an external module to get your input by <b>ReadLine</b>, and in the case of textual input, remove the EOL (end of line or \n character) generated by pressing enter. There is an easier way. But first some theory...</h3>
<h2>I/O Devices</h3>
<h3>Modern languages like C, C++, Java, Perl etc. recognise that there is normally a keyboard and screen attached to a computer; or at the very least some type of input and output device. They also recognise that there is a need to be able to log errors. To this end, these languages recognise the existance of three standard I/O devices:
<ol>
<li>&lt;STDIN&gt; - the standard input device; normally a keyboard, once upon a time a card-reading machine but just as possibly electrified Bongo Drums.</li>
<li>&lt;STDOUT&gt; - the standard output device; normally a screen, once a tele-printer but if you happened to have a spare elephant your could wire him in as an audio-prompt.</li>
<li>&lt;STDERR&gt; - the standard logging mechanism whereby all system events are recorded; today under most *NIX systems this is a file called <b>messages</b> in the <b>/var/log</b> directory. In the middle ages it was normally a tonsured monk who would write down the errors of log events generated by the computer; monks were used as they tended to be literate while most of the population were not.</li>
</ol>

<h2>Output</h2>
<h3>Unless you specify otherwise it is assumed that output is destined for the screen. Hence the ease with which you have been able to just <b>print</b> directly to the screen. If you want your output to go elsewhere, a few other (simple) steps must be followed. We'll come to samples of these soon enough. In the meantime you do not need to specify &lt;STDOUT&gt; as the destination of your output.</h3>
<h2>'Error' Logging</h2>
<h3>Stangely enough, a positive outcome is considered an error - but a good error not a bad one! If you want events - good or bad - recorded in the systems event log so that you can refer to them after the program ends, direct them to &lt;STDERR&gt;. In light of the fact that many programs wind up only logging positive outcomes the device name &lt;STDLOG&gt; may have been a better choice instead of what we are using.</h3>
<h2>Input</h2>
<h3>Input is assumed to come from the keyboard. The command used to do it is the only question. When we wrote the Hello World program we were demonstrating that we could generate output, as well as run a program successfully. The next challenge for a programmer seeing a new system or a new language is how to take input from the keyboard. Luckily &lt;STDIN&gt; is pre-declared and we only have to use it. This does away with the cumbersome ReadLine method</h3>
<h3>Furthermore, Perl has many, many functions to manipulate text; including the <b>chop</b> command. So instead of the powerful but seemly difficult <b>s///</b> mechanism the chop function just chops off the EOL character. Snip. Done!</h3>
<h2>Task 004</h2>
<h3>Copy and modify your <b>greetme.pl</b> file to look as below. Use the command:
<br><font face="Courier" >cp greetme.pl   greetmegood.pl</font>
<br>to copy the file then use:
<br><font face="Courier" >vi greetmegood.pl</font>
<br>to open and edit the new file....so that your program looks like this:</h3>
<font face="Courier" >
<p>#!/usr/bin/perl
<br>&nbsp;&nbsp;
<br>&nbsp;&nbsp;print "Hello. Who are you?\n";
<br>&nbsp;&nbsp;$name = &lt;STDIN&gt;;
<br>&nbsp;&nbsp;chop $name;
<br>&nbsp;&nbsp;print "Hello, $name.\n";
<p>
</font>
<h3>You should now have a program that says 'Hello' back to you with your name and all output properly positioned but the program should be much simpler than the original one..</h3>

<h2>Making Decisions: The <b>if</b> Operator &amp; Statement</h2>
<h3>The programs we have written so far all used a 'straight path' from start to finish. We could predict what the program could do starting from the first line. In reality, this isn't normally the case with a computer program. Normally, a program will have to respond in a manner appropriate to the input - which will vary.</h3>
<h3>Thus far, we asked a name and said hello to that name. The following program will also ask a name, but also an age. It will repond to the age given by informing the user if they may vote or not. For this, the program needs to be able to make a decision; hence, the <b>if</b> function or statement.</h3>
<h2>Task 005</h2>
<h3>Try entering the program below putting your own details in the comment section:</h3>
<font face="Courier" >
<br>#!/usr/bin/perl
<br>#
<br># ----------------------------------------------------------------------------------
<br># Author:			Date:		
<br># Title:	responder.pl	Purpose:	
<br># ----------------------------------------------------------------------------------
<br>#
<br>&nbsp;&nbsp;
<br>&nbsp;&nbsp;print "Hello. Who are you? ";
<br>&nbsp;&nbsp;$name = &lt;STDIN&gt;;
<br>&nbsp;&nbsp;chop $name;
<br>&nbsp;&nbsp;print "How old are you? ";
<br>&nbsp;&nbsp;$age = &lt;STDIN&gt;;
<br>&nbsp;&nbsp;if ($age ge 18)
<br>&nbsp;&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;chop $age;
<br>&nbsp;&nbsp;&nbsp;&nbsp;print "Hello, $name. Did you know that at $age you're old enough to vote?\n";
<br>&nbsp;&nbsp;}
</font>
<h3>Sample output from the program is shown here:
<p>
<center><img width="90%"  src="/images/responder01-pl.png" /></center>
<br>
<h3>There are a few things to note:
<ol>
<li>What happens if a value &lt; 18 is entered?</li>
<li>Why do we not need to <b>chop</b> the line break when making the comparison in the <b>if</b> but we do before using $age in an output statement; modify the program and re-run if you're not sure.</li>
<li>The if function (in context, the whole thing is called an if statement) compares two values. If the comaprision has a TRUE outcome the code immediately after will be executed; otherwise - with a FALSE outcome - some other or no other code will be executed.</li>
<li>Note how the code to be executed in the case of a TRUE outcome is grouped into a block with { and } brackets. This is important.</li>
<li>Note the <b>ge</b> operator - which stands for <b>g</b>reater than or <b>e</b>qual. There are other operators: lt, le, eq, gt, ne which should be easy to understand. The tradtional &lt;, = and &gt; symbols are used for numeric comparison - but ask yourself why the text comparator was used here...?</li>
<li>Finally, note how no response is made it the user is not entitled to vote. This is poor programming practice and will be solved in the next task</li>
</ol>
<h3>More anon...
<!--#exec cgi="/cgi-bin/shtml/navigate.shtml" -->
</div>
</body>
</html>