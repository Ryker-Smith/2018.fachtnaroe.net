<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.06 [en] (Win95; I) [Netscape]">
   <META NAME="Author" CONTENT="Eric Phelps">
   <META NAME="Description" CONTENT="Batch files often rely on secondary batch files and debug scripts in order to complete their tasks. Often, these files can't be allowed or be trusted to exist on a permanent basis. They must be generated and deleted on-the-fly, as they are needed.">
   <TITLE>Creating Secondary Batch Files and Scripts</TITLE>
</HEAD>
<BODY>

<CENTER>
<H2>
Creating Secondary Batch Files and Scripts</H2></CENTER>

<CENTER>
<HR WIDTH="100%"><I>Batch files often rely on secondary batch files and
debug scripts in order to complete their tasks. Often, these files can't
be allowed or be trusted to exist on a permanent basis. They must be generated
and deleted "on-the-fly", as they are needed.</I>
<HR WIDTH="100%"></CENTER>

<P><A NAME="echo"></A>The most common technique for generating secondary
files is through the use of the echo command:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=CENTER VALIGN=CENTER><I>MAIN.BAT</I></TD>

<TD></TD>

<TD ALIGN=CENTER VALIGN=CENTER><I>TEMP.BAT</I></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP NOWRAP><B><TT>@echo off</TT></B>
<BR><B><TT>echo Main running</TT></B>
<BR><B><TT>echo @echo off > temp.bat</TT></B>
<BR><B><TT>echo echo Temp running >> temp.bat</TT></B>
<BR><B><TT>call temp.bat</TT></B>
<BR><B><TT>del temp.bat</TT></B>
<BR><B><TT>echo Main ending</TT></B></TD>

<TD NOWRAP><I>&lt;&lt;&lt; This batch file</I>
<P><I>will generate this >>></I></TD>

<TD ALIGN=LEFT VALIGN=TOP NOWRAP><B><TT>@echo off</TT></B>
<BR><B><TT>echo Temp running</TT></B></TD>
</TR>
</TABLE>
Frankly, this is simple enough that it doesn't bear explaining much beyond
the example code. Unless you'll be needing to put special characters in
the secondary file, this technique will probably be all you need.
<P>
<HR WIDTH="100%"><A NAME="percent"></A>A problem occurs when you want the
secondary TEMP.BAT to contain redirection or piping characters. Suppose
you want TEMP.BAT to contain the following line:
<BR><B><TT>chkdsk | find "65535" > nul</TT></B>
<BR>(By the way, the above command will usually return an errorlevel of
one if you have a boot-sector virus or are using special boot software)
<BR>This line, for example, won't work:
<BR><B><TT>echo chkdsk|find "65535">nul > TEMP.BAT</TT></B>
<BR>What happens is DOS simply processes things left to right, sending
the string "chkdsk" into FIND, which fails to find "65535", which dumps
nothing into nul (and sets an errorlevel of one), then sends nothing into
TEMP.BAT, resulting in a zero-byte TEMP.BAT file. Not good. If we put quotes
around the whole thing, it all gets into TEMP.BAT, but with the quotes
still intact:
<BR><B><TT>echo "chkdsk|find "65535">nul" > TEMP.BAT</TT></B>
<BR>puts
<BR><B><TT>"chkdsk|find "65535">nul"</TT></B>
<BR>into TEMP.BAT. Clearly we're making progress, but we aren't there yet.
To go the next step requires an understanding of how DOS processes lines
(A little something Dale Edgett pointed out for all of us in <A HREF="http://www.zdnet.com/pcmag/issues/1421/pcm00155.htm">PC
Magazine</A>):
<P><B><FONT COLOR="#0000FF">DOS parses a line once, from left to right.
If it finds a double quote ( " ), it treats everything up to the next double
quote as text. If it finds %%, it replaces them with %. If it finds % followed
by a number (%0 through %9), it replaces those two characters with the
value of the corresponding command line argument. If it finds % followed
by anything else, it replaces everything up to the next % with the value
of the corresponding environment variable (for example, %PROMPT% would
probably get replaced by $P$G).</FONT></B>
<P>Now, let's suppose we had this line in our TEMP.BAT:
<BR><B>%"%<TT> chkdsk | find "65535" > nul </TT>%"%</B>
<BR>What would happen is the<B><TT> </TT>%"%<TT> </TT></B>characters would
be replaced by the value of the environment variable whose name is<B> "</B>.
Well, as long as you don't have a variable whose name is a double quote,
this
means they will be replaced by nothing. In other words, it is totally harmless
to stick<B> %"%</B> in anywhere we want.
<P>So what would happen if our MAIN.BAT had the following line in it?
<BR><B><TT>echo</TT> %%"%%<TT> chkdsk | find "65535" > nul </TT>%%"%% <TT>>
temp.bat</TT></B>
<BR>DOS would replace the first %% with a single %, then it would see the
quote. Seeing the quote, it would remember to ignore all piping and redirection
symbols up to the next quote. This means our quote protection ends at the
quoted 65535, but it picks up again at the end of the number and continues
to the last quote (far enough to protect all but the last redirection symbol
which we want to act as a redirection anyway). DOS then continues to process
the line, replacing the rest of the %% with %. After processing the line,
it executes it, echoing our desired line
<BR><B>%"%<TT> chkdsk | find "65535" > nul </TT>%"%</B>
<BR>into TEMP.BAT. All the piping and redirection is delivered intact,
and we can ignore the %<B>"</B>%, since DOS will ignore it.
<P>
<HR WIDTH="100%">
<P><A NAME="spaces"></A>Probably the easiest way to echo complex lines
into a secondary batch file is to make them unique, then TYPE the entire
main batch file through FIND, letting FIND filter things so that only the
desired lines get through. The trick is to find something unique you can
add to the desired lines that won't affect what those lines do. The universal
answer is spaces. Whether you will be creating a DEBUG script, a QBASIC
file, or a batch file, leading spaces are always ignored. Consider this
file named MAIN.BAT:
<P><B><TT>goto process</TT></B>
<BR><B><TT>&nbsp;&nbsp; chkdsk | find "65535" > nul</TT></B>
<BR><B><TT>&nbsp;&nbsp; if errorlevel 1 echo You have a virus!</TT></B>
<BR><B><TT>:process</TT></B>
<BR><B><TT>type MAIN.BAT | find "&nbsp;&nbsp; "| find /v "&nbsp;&nbsp;&nbsp;
" > TEMP.BAT</TT></B>
<BR><B><TT>call temp.bat</TT></B>
<BR><B><TT>del temp.bat</TT></B>
<P>Because the two lines we want sent to TEMP.BAT are preceeded by three
spaces, they are easy to pick out of the batch file. Unfortunately, the
line with the FIND in it also has three spaces in it (between the quotes).
By adding a reverse search for another unique string (I chose four spaces.
Put your cursor on it and count if you don't believe me.), we can insure
that the FIND line won't find itself!.Only the desired lines will be redirected
into the TEMP.BAT. If we wanted to, we could add more code to create another
temporary batch file. The lines for this next file would have four spaces
at the beginning of each line, and the FIND line for it would do a reverse
search on five spaces. Another batch file could be created that would be
identified by five leading spaces, and it's FIND line would include a reverse
search for six spaces. And so on. Very flexible. And all that indenting
makes the code easier to read too!
<P>
<HR WIDTH="100%">
<P><A NAME="hybrid"></A>A hybrid approach which contains the best (the
worst?) of the two above techniques eliminates the need for a reverse search
when creating secondary batch files (not DEBUG or BASIC files). Relying
on the fact that nonexistent environment variables can be inserted in a
batch file without harm, we can use them as markers to make desired lines
unique. Consider this MAIN.BAT example:
<P><B><TT>goto process</TT></B>
<BR><B><TT>%"1% chkdsk | find "65535" > nul</TT></B>
<BR><B><TT>%"1% if errorlevel 1 echo You have a virus!</TT></B>
<BR><B><TT>:process</TT></B>
<BR><B><TT>type MAIN.BAT | find "%%""1%%" > TEMP.BAT</TT></B>
<BR><B><TT>call temp.bat</TT></B>
<BR><B><TT>del temp.bat</TT></B>
<P>Trust me for just a second. Because we use TYPE and FIND, our desired
lines (the second and third lines, both marked with %"1%) will be sent
exactly as they appear into the secondary TEMP.BAT. These two lines won't
be "processed" until TEMP.BAT is run. When that happens, %"1% will be replaced
by the value of the environment variable "1 , which is nothing. That much
was easy to figure out. Now I'll earn your trust and explain the FIND line...
First, DOS will process that line and convert the %% to %, reducing our
FIND expression from
<BR><B><TT>find "%%""1%%"</TT></B>
<BR>to
<BR><B><TT>find "%""1%"</TT></B>
<BR>Next, we have to concern ourselves with what FIND will be looking for,
namely everything inside the quotes:
<BR><B><TT>%""1%</TT></B>
<BR>But -- did you know how to make FIND search for a quote ( " )? You
put two of them in a row ( "" ). So what FIND will actually be searching
for is
<BR><B><TT>%"1%</TT></B>
<BR>Since that particular string only occurs on the second and third line
of MAIN.BAT (our desired lines), they are the only ones that will be found
by FIND. No reverse search is needed thanks to the way FIND translates
quotes!
<P>If you need to have your MAIN.BAT create several secondary batch files,
you could label and find them this easily:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP NOWRAP><B><I>Unique Line Markers</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<CENTER><B><I>FIND</I></B></CENTER>
</TD>
</TR>

<TR>
<TD><B><TT>%"1%</TT></B></TD>

<TD NOWRAP><B><TT>find "%%""1%%"</TT></B></TD>
</TR>

<TR>
<TD><B><TT>%"2%</TT></B></TD>

<TD NOWRAP><B><TT>find "%%""2%%"</TT></B></TD>
</TR>

<TR>
<TD><B><TT>%"3%</TT></B></TD>

<TD NOWRAP><B><TT>find "%%""3%%"</TT></B></TD>
</TR>

<TR>
<TD><B><TT>%"4%</TT></B></TD>

<TD NOWRAP><B><TT>find "%%""4%%"</TT></B></TD>
</TR>

<TR>
<TD><B><TT>%"batchfile5%</TT></B></TD>

<TD NOWRAP><B><TT>find "%%""batchfile5%%"</TT></B></TD>
</TR>
</TABLE>
The important thing is that you keep the quote. Whether you add numbers
or names after the quote is up to you.
<P>
<HR WIDTH="100%">
<P><A NAME="prompt"></A>The old way of getting redirection and pipe symbols
into secondary batch files was to capture a prompt. The advantage of this
way is that you don't have to know the name of the file, since you won't
be "typing" it. And it really only takes two lines of code. Unfortunately,
it does run a separate DOS session (do you have enough memory?). Consider
this example:
<P><B><TT>echo @prompt chkdsk $B find "65535" $G nul > temp1.bat</TT></B>
<BR><B><TT>command /c temp1.bat > temp2.bat</TT></B>
<BR><B><TT>echo if errorlevel 1 echo You have a virus!>> temp2.bat</TT></B>
<BR><B><TT>call temp2.bat</TT></B>
<P>When the first line in the above batch file is run, it will create a
secondary batch file TEMP1.BAT containing:
<BR><B><TT>@prompt chkdsk $B find "65535" $G nul</TT></B>
<P>When this TEMP1.BAT is run by COMMAND (allowing everything, including
the prompts, to be redirected and captured), it will set the prompt to
<BR><B><TT>chkdsk | find "65535" > nul</TT></B>
<BR>because $B becomes a | and $G becomes > and we capture the prompt just
like that and redirect it into TEMP2.BAT. Since the second line of my desired
TEMP2.BAT has no special characters, I simply echo it and append it to
TEMP2.BAT.&nbsp; TEMP2.BAT will then contain
<BR><B><TT>chkdsk | find "65535" > nul</TT></B>
<BR><B><TT>if errorlevel 1 echo You have a virus!</TT></B>
<P>
<HR WIDTH="100%">
<P>There is another way of getting pipes and redirections into secondary
batch files by capturing a prompt. It doesn't launch a separate DOS session
and it doesn't create files that have extra spurious carriage returns in
them, but it only works under Windows 95 (At least I know it won't work
under DOS 6.00 or 6.22).
<P><B><TT>@ctty nul</TT></B>
<BR><B><TT>prompt chkdsk $B find "65535" $G</TT></B>
<BR><B><TT>echo on</TT></B>
<BR><B><TT>if exist nul>temp.bat</TT></B>
<BR><B><TT>nul</TT></B>
<BR><B><TT>echo off</TT></B>
<BR><B><TT>prompt $p$g</TT></B>
<BR><B><TT>ctty con</TT></B>
<BR><B><TT>echo if errorlevel 1 echo You have a virus!>> temp.bat</TT></B>
<BR><B><TT>call temp.bat</TT></B>
<P>This is a totally undocumented trick (bug, feature?). If you run IF
EXIST (or IF NOT EXIST) without the required command <B>and</B> specify
a redirection destination instead, <B>and</B> if ECHO is ON, <B>and</B>
if the IF test is true, <B>then </B>the command following the IF line will
be redirected, prompt and all into the file specified on the IF line.
<P>First we set the prompt to
<BR><B><TT>chkdsk | find "65535" ></TT></B>
<BR>We can't put the nul on the end of the prompt, because we need a non-blank
line following the IF line (and that's where the nul will go). Since we
need the IF line to test true, we look for nul. NUL is a device which always
exists, so IF EXIST NUL will always be true. The next line is also nul
(a coincidence), and this line will be (1) run as a command, and (2) be
captured appended to the prompt. Luckily, nul is not a valid command, so
nothing bad will come of it being on a command line (except a harmless
error message, which is what the ctty is hiding). At this point, we will
have
<BR><B><TT>chkdsk | find "65535" >nul</TT></B>
<BR>in TEMP.BAT. We can then undo all our setup work, fixing echo, prompt,
and ctty. The final step is to add the second line to our TEMP.BAT, but
this is a no-tricks simple redirection.
<BR>&nbsp;
<P><BR>
<CENTER>
<P>Bad links? Questions? <A HREF="mail.htm">Send
me mail</A>.</CENTER>

<BR>&nbsp;
</BODY>
</HTML>
