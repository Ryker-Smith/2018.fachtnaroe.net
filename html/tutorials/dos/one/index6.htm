<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html;
charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I)
[Netscape]">
   <META NAME="Author" CONTENT="Eric Phelps">
   <META NAME="Description" CONTENT="How to use FOR and CHOICE to select
individual characters in a word.">
   <TITLE>Batch Files - Processing Characters in a Word</TITLE>
</HEAD>
<BODY>

<CENTER>
<H2>
Batch Files: Processing Characters in a Line</H2></CENTER>

<CENTER>
<HR WIDTH="100%"><I>If you have Windows 95, you can use <A
HREF="#choice">CHOICE</A>.
If you have DOS 5 or 6, you can use <A HREF="#for">FOR</A> as well. If
you have any common sense, you'll use Basic.</I>&nbsp;
<HR WIDTH="100%"></CENTER>


<P><A NAME="for"></A><B><FONT SIZE=+1>FOR </FONT></B>Since it won't work
on Windows 95, I'll cover it here just enough to allow you to understand
it so you can convert any old code you might run across. It seems that
an undocumented quirk of FOR was that any text in the "set" following a
slash would be interpreted as two items: The character following the slash
was one item, while the remainder of the word was another item:
<PRE><B>Microsoft(R) MS-DOS(R) Version 5.00
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(C)Copyright Microsoft Corp 1981-1991.

E:\>for %x in (/one two) do echo %x

E:\>echo o
o

E:\>echo ne
ne

E:\>echo two
two

E:\></B></PRE>
Notice how the word "one" was split into two parts, "o" and "ne". Using
this quirk allowed words (file names, times, dates, etc.) to be picked
apart character-by-character. Unfortunately, like all quirks, bugs, and
undocumented features, there was no guarantee it would be the same on
subsequent
releases. Check out the different behavior under Windows 95:
<PRE><B>Microsoft(R) Windows 95
&nbsp;&nbsp; (C)Copyright Microsoft Corp 1981-1995.

E:\>for %x in (/one two) do echo %x

E:\>echo /ONE
/ONE

E:\>echo two
two

E:\></B></PRE>
Windows 95 now capitalizes everything following a slash. Another quirk.
Take advantage of this capitalization only if you don't mind all your code
failing on the next release of DOS.

<P>
<HR WIDTH="100%">

<P><A NAME="choice"></A><B><FONT SIZE=+1>CHOICE</FONT></B> Using choice
to extract individual characters will work on all DOS versions.
<BR>School time! Type this at a DOS prompt:
<BR><B><TT>choice /c12345</TT></B>
<BR>What you get is
<BR><B><TT>[1,2,3,4,5]?</TT></B>
<BR>which is a demo of magic! (Go ahead and press 1,2,3,4, or 5) Choice
has inserted delimiters (Commas in this case. Other delimiters are spaces,
semicolons, and equals signs) between all our arguments. Well, almost.
We need extra delimiters to separate the 1 and 5 from the brackets. So
do this:
<BR><B><TT>choice /c=12345=</TT></B>
<BR>Notice I used equals signs. Most people use semicolons. No real
difference.
You get this:
<BR><B><TT>[=,1,2,3,4,5,=]?</TT></B>
<BR>Big progress. Now comes trick #2. Choice allows you to specify a
prompt.
You just add it to the end of the choice line and it shows up at the
beginning
of the output. Try this simple example:
<BR><B><TT>choice /c12345 Pick a number</TT></B>
<BR>You get this:
<BR><B><TT>Pick a number[1,2,3,4,5]?</TT></B>

<P>But we will use the prompt as a way to get a batch file name at the
beginning of the line. Building on our previous example:
<BR><B><TT>choice /c=12345= test.bat=</TT></B>
<BR>Which gives this:
<BR><B><TT>test.bat=[=,1,2,3,4,5,=]?</TT></B>
<BR>Notice the equals sign after the batch file name? For increased
readability,
you should replace it with a space. But I can't show a space at the end
of the line! It works either way (space or equals).

<P>Next trick is to stop choice from hanging waiting for your keypress.
We can just echo in one of the choices. To make it truly generic, we'll
use the equals sign (since 12345 will be replaced by REAL data later on):
<BR><B><TT>echo = | choice /c=12345= test.bat=</TT></B>

<P>We now have a perfectly good command line. Let's go ahead and put this
line into a batch file:

<P><B><TT>echo = | choice /c=12345= test.bat > temp.bat</TT></B>
<BR>Notice how I used a space after my "test.bat" instead of an equals
sign. Our generated temp.bat will contain:
<BR><B><TT>test.bat [=,1,2,3,4,5,=]?</TT></B>

<P>Now let's create a simple test.bat. Try this:
<BR><B><TT>@echo off</TT></B>
<BR><B><TT>:start</TT></B>
<BR><B><TT>if [%1]==[] goto end</TT></B>
<BR><B><TT>echo %1</TT></B>
<BR><B><TT>shift</TT></B>
<BR><B><TT>goto start</TT></B>
<BR><B><TT>:end</TT></B>

<P>All this test.bat does is display the arguments in order. A great
generic
test program any time you are working with multiple arguments! When we
run our TEMP.BAT, it will run TEST.BAT and give us this result:
<BR><B><TT>[</TT></B>
<BR><B><TT>1</TT></B>
<BR><B><TT>2</TT></B>
<BR><B><TT>3</TT></B>
<BR><B><TT>4</TT></B>
<BR><B><TT>5</TT></B>
<BR><B><TT>]?</TT></B>
<BR>The first displayed argument is "<B><TT>[</TT></B>", the second is
"<B><TT>1</TT></B>", and so on. So your TEST.BAT could refer to %2 through
%6 to display the first five characters.

<P>No we are ready to go fully generic. We'll assume we'll have a batch
file that will be passed a word as an argument. The word will be
<B><TT>%1</TT></B>
(the first argument). So we do away with the 12345:
<BR><B><TT>echo = | choice /c=%1= test.bat > temp.bat</TT></B>
<BR>So you just put the above line in a simple batch file and call it with
a word (one word with no spaces) as an argument. It will create a temp.bat
which will run a test.bat. You build your test.bat to do whatever you want
with the individual letters in the word.
<P><CENTER>Bad links? Questions? <A HREF="mail.htm">Send me mail</A>.</CENTER>

</BODY>
</HTML>

