<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Eric Phelps">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; I) [Netscape]">
   <TITLE>Creating Line Fragments Using DEBUG</TITLE>
</HEAD>
<BODY>

<CENTER>
<H2>
Creating Line Fragments Using DEBUG</H2></CENTER>

<CENTER>
<HR WIDTH="100%"><I>DEBUG can create a "line fragment" (a line without
the usual carriage-return). No assembly language required! Just use DEBUG
as a binary editor.&nbsp;</I>
<HR WIDTH="100%"></CENTER>


<P>Like lots of DOS commands, DEBUG can be run from the keyboard or from
a redirected file. In the batch file below, I use ECHO to create a file
(unimaginatively named SCRIPT) which will be redirected into DEBUG:

<P><B><TT>echo e 100 "set value="> script</TT></B>
<BR><B><TT>echo rcx>> script</TT></B>
<BR><B><TT>echo a>> script</TT></B>
<BR><B><TT>echo n fragment.txt>> script</TT></B>
<BR><B><TT>echo w>> script</TT></B>
<BR><B><TT>echo q>>script</TT></B>
<BR><B><TT>debug &lt; script > nul</TT></B>
<BR><B><TT>del script</TT></B>

<P>The above batch code will create a "script" file containing this:<BR>
<BR>
<BR><B><TT>e 100 "set value="</TT></B>
<BR><B><TT>rcx</TT></B>
<BR><B><TT>a</TT></B>
<BR><B><TT>n fragment.txt</TT></B>
<BR><B><TT>w</TT></B>
<BR><B><TT>q</TT></B>

<P>Let's examine the script file which will be created. You could actually
start debug and hand-enter all the above commands. First we <B><FONT SIZE=+1>E</FONT></B>nter
(starting at address <B><FONT SIZE=+1>100</FONT></B>, the default beginning
of all debug files) some text. This could be either space or comma delimited
hex values or quoted text. I chose to enter <B><FONT SIZE=+1>SET VALUE=</FONT></B>.
You could enter whatever you wanted. Obviously, in this example I'm planning
on creating an environment variable named VALUE and filling it with something!
Next I need to set the file size. This part requires you to count characters.
My text uses a total of 10 characters (which is hex A). The file length
is stored in the CX register, and the <B><FONT SIZE=+1>RCX</FONT></B> command
allows us to enter a new value for the CX register. The value we enter
is <B><FONT SIZE=+1>A</FONT></B>. At this point, everything in memory is
the way we want it. We enter a <B><FONT SIZE=+1>N</FONT></B>ame for the
file ( I chose <B><FONT SIZE=+1>FRAGMENT.TXT</FONT></B>), then <B><FONT SIZE=+1>W</FONT></B>rite
it to the disk. We can then <B><FONT SIZE=+1>Q</FONT></B>uit.

<P>After running the above batch file, we would have a 10 byte file named
FRAGMENT.TXT containing only SET VALUE= with no CR/LF at the end of the
line.&nbsp;
<HR WIDTH="100%">

<P>Obviously, if you know exactly how long your text is going to be (10
bytes in this example), you could simply set the CX register appropriately
(to A in this case). If you want to create a more general utility that
could accept any reasonable line, you might try this trick: Fill a line
with EOF characters (hex 1A). Let your desired data overwrite some of the
EOF characters. When DOS processes this frankenstein line, it will ignore
all the EOF characters. Believe it. Here's what you do:

<P><B><TT>echo f 100 L 80 1a> script</TT></B>
<BR><B><TT>echo e 100 %2 %3 %4 %5 %6 %7 %8 %9>> script</TT></B>
<BR><B><TT>echo rcx>> script</TT></B>
<BR><B><TT>echo 80>> script</TT></B>
<BR><B><TT>echo n %1>> script</TT></B>
<BR><B><TT>echo w>> script</TT></B>
<BR><B><TT>echo q>>script</TT></B>
<BR><B><TT>debug &lt; script > nul</TT></B>
<BR><B><TT>del script</TT></B>

<P>This will <B><FONT SIZE=+1>F</FONT></B>ill memory starting at address
<B><FONT SIZE=+1>100</FONT></B> (the default) for a <B><FONT SIZE=+1>L</FONT></B>ength
of<FONT SIZE=+1> <B>80</B></FONT> (hex) with the DOS end-of-file character
<B><FONT SIZE=+1>1A</FONT></B>. 80 hex is 128 decimal, which is the maximum
command-line length. You would pass the file name as the first argument
and your desired text as additional arguments. You'd be replacing the inflexible
FRAGMENT.TXT and SET VALUE= with the more general %1 and %2. If it became
important to clean the resulting file up (set it's length so there were
no EOF characters in it), it could be accomplished by either of the two
methods:
<BR><B><TT>copy /a fragment.txt clean.txt</TT></B>
<BR><B><TT>type fragment.txt > clean.txt</TT></B>
<BR>Of course, if we use COPY to concatenate text files, we won't need
to specify the /a switch:
<BR><B><TT>copy fragment.txt + someline.txt result.txt</TT></B>
<BR>Typically, SOMELINE.TXT would contain a file name or other important
data, and RESULT.TXT would be a batch file (Maybe I should've called it
RESULT.BAT ?)

<P>
<HR WIDTH="100%">If you're determined to create a COM file ahead of time,
you might want to investigate <A HREF="ftp://ftp.zdnet.com/pcmag/1993/1026/v12n18.zip">ECH.COM</A>,
a replacement for the ECHO command which doesn't add the terminating CR/LF
to the end of the line.&nbsp;
<HR WIDTH="100%">

<P>Here's a trick that combines the fragment, a batch file, and a debug
script all in one. As presented, it creates a fragment, adds whatever you
want to the fragment to create a new line, then executes the new line (assuming
the new line is a batch file).

<P><B><TT>@echo off</TT></B>
<BR><B><TT>echo set value=> ~.bat</TT></B>
<BR><B><TT>echo e 010a 1a >> ~.bat</TT></B>
<BR><B><TT>echo w >> ~.bat</TT></B>
<BR><B><TT>echo q >> ~.bat</TT></B>
<BR><B><TT>type ~.bat | debug ~.bat> nul</TT></B>
<BR><B><TT>type ~.bat | more> ~.bat</TT></B>
<BR><B><TT>echo Your Command Output Goes Here!>> ~.bat</TT></B>
<BR><B><TT>call ~.bat</TT></B>
<BR><B><TT>del ~.bat</TT></B>

<P>First we put <B>SET VALUE=</B> (with an unavoidable carriage return
at it's end) in the file. Then we append a DEBUG script to the same file.
Don't worry, DEBUG ignores batch commands and won't have a problem modifying
it's own script. The <B>E 010A 1A</B> will <B><FONT SIZE=+1>E</FONT></B>nter
the value <B>1A</B> (the end-of-file character) at the address <B>010A</B>.
Since the file always starts at 0100, this is "A" (ten) characters in.
The "s" in "set value" is the zero character, the "e" is the first, the
"t" is the second, ... which makes the tenth character just after the equal
sign. The <B>ECHO W</B> will cause the DEBUG script to <B><FONT SIZE=+1>W</FONT></B>rite
our change to the disk, and the <B>ECHO Q</B> will <B><FONT SIZE=+1>Q</FONT></B>uit
DEBUG. We then <B>TYPE</B> the script into DEBUG and redirect it's output
into NUL so as not to garbage up the screen. Using TYPE and the "pipe"
is what allows DEBUG to seem to modify a running script! The next step
is to chop our file off where we inserted the end-of-file character. The
<B>TYPE ~.BAT | MORE > ~.BAT</B> does this. The chopping is done by the
TYPE command, but I pipe it through MORE just to gain an intermediate step
which allows me to use the same name for the output file. MORE has the
interesting habit of adding a carriage return to the start of a file, but
I am only concerned with protecting the end of my file, so this is okay.
Now you can append anything you want any way you want. The end result of
~.BAT in this example is
<BR><B><TT>set value=Your Command Output Goes Here!</TT></B>
<P><CENTER>Bad links? Questions? <A HREF="mail.htm">Send me mail</A>.</CENTER>
</BODY>
</HTML>
